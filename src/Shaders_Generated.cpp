// Thise file was generated by a glsl preprocessor

namespace soko
{
    struct ShaderInfo
    {
        struct Info_PbrMesh
        {
            static const char* VertexSource;
            static const char* FragmentSource;
            
            GLuint handle;
            
            struct VertexShader
            {
                struct Uniforms
                {
                    GLint uViewProjMatrix;
                    GLint uModelMatrix;
                    GLint uNormalMatrix;
                } uniforms;

                struct VertexAttribs
                {
                    GLuint aPos = 0;
                    GLuint aNormal = 1;
                    GLuint aUV = 2;
                    GLuint aTangent = 3;
                } vertexAttribs;

            } vertex;
            struct FragmentShader
            {
                struct DirLight
                {
                    GLint dir;
                    GLint color;
                };

                struct Uniforms
                {
                    DirLight uDirLight;
                    GLint uViewPos;
                    GLint uIrradanceMap;
                    GLint uEnviromentMap;
                    GLint uBRDFLut;
                    GLint uAlbedoMap;
                    GLint uRoughnessMap;
                    GLint uMetalnessMap;
                    GLint uNormalMap;
                    GLint uCustomMaterial;
                    GLint uCustomAlbedo;
                    GLint uCustomRoughness;
                    GLint uDebugF;
                    GLint uDebugG;
                    GLint uDebugD;
                    GLint uDebugNormals;
                    GLint uAO;
                } uniforms;

                struct Samplers
                {
                    Sampler uIrradanceMap = { 0, GL_TEXTURE0 };
                    Sampler uEnviromentMap = { 1, GL_TEXTURE1 };
                    Sampler uBRDFLut = { 2, GL_TEXTURE2 };
                    Sampler uAlbedoMap = { 3, GL_TEXTURE3 };
                    Sampler uRoughnessMap = { 4, GL_TEXTURE4 };
                    Sampler uMetalnessMap = { 5, GL_TEXTURE5 };
                    Sampler uNormalMap = { 6, GL_TEXTURE6 };
                } samplers;

            } fragment;
        } PbrMesh;
    };

    ShaderInfo::Info_PbrMesh CompileProgram_PbrMesh()
    {
        ShaderInfo::Info_PbrMesh result = {};
        auto handle = CreateProgram(ShaderInfo::Info_PbrMesh::VertexSource, ShaderInfo::Info_PbrMesh::FragmentSource);
        if (handle)
        {
            result.handle = handle;
            // NOTE: Assign vertex shader uniforms
            result.vertex.uniforms.uViewProjMatrix = glGetUniformLocation(handle, "uViewProjMatrix");
            result.vertex.uniforms.uModelMatrix = glGetUniformLocation(handle, "uModelMatrix");
            result.vertex.uniforms.uNormalMatrix = glGetUniformLocation(handle, "uNormalMatrix");

            // NOTE: Assign fragment shader uniforms
            result.fragment.uniforms.uDirLight.dir = glGetUniformLocation(handle, "uDirLight.dir");
            result.fragment.uniforms.uDirLight.color = glGetUniformLocation(handle, "uDirLight.color");
            result.fragment.uniforms.uViewPos = glGetUniformLocation(handle, "uViewPos");
            result.fragment.uniforms.uIrradanceMap = glGetUniformLocation(handle, "uIrradanceMap");
            result.fragment.uniforms.uEnviromentMap = glGetUniformLocation(handle, "uEnviromentMap");
            result.fragment.uniforms.uBRDFLut = glGetUniformLocation(handle, "uBRDFLut");
            result.fragment.uniforms.uAlbedoMap = glGetUniformLocation(handle, "uAlbedoMap");
            result.fragment.uniforms.uRoughnessMap = glGetUniformLocation(handle, "uRoughnessMap");
            result.fragment.uniforms.uMetalnessMap = glGetUniformLocation(handle, "uMetalnessMap");
            result.fragment.uniforms.uNormalMap = glGetUniformLocation(handle, "uNormalMap");
            result.fragment.uniforms.uCustomMaterial = glGetUniformLocation(handle, "uCustomMaterial");
            result.fragment.uniforms.uCustomAlbedo = glGetUniformLocation(handle, "uCustomAlbedo");
            result.fragment.uniforms.uCustomRoughness = glGetUniformLocation(handle, "uCustomRoughness");
            result.fragment.uniforms.uDebugF = glGetUniformLocation(handle, "uDebugF");
            result.fragment.uniforms.uDebugG = glGetUniformLocation(handle, "uDebugG");
            result.fragment.uniforms.uDebugD = glGetUniformLocation(handle, "uDebugD");
            result.fragment.uniforms.uDebugNormals = glGetUniformLocation(handle, "uDebugNormals");
            result.fragment.uniforms.uAO = glGetUniformLocation(handle, "uAO");

            //NOTE: Setting samplers
            glUseProgram(handle);
            glUniform1i(result.fragment.uniforms.uIrradanceMap, (GLint)result.fragment.samplers.uIrradanceMap.sampler);
            glUniform1i(result.fragment.uniforms.uEnviromentMap, (GLint)result.fragment.samplers.uEnviromentMap.sampler);
            glUniform1i(result.fragment.uniforms.uBRDFLut, (GLint)result.fragment.samplers.uBRDFLut.sampler);
            glUniform1i(result.fragment.uniforms.uAlbedoMap, (GLint)result.fragment.samplers.uAlbedoMap.sampler);
            glUniform1i(result.fragment.uniforms.uRoughnessMap, (GLint)result.fragment.samplers.uRoughnessMap.sampler);
            glUniform1i(result.fragment.uniforms.uMetalnessMap, (GLint)result.fragment.samplers.uMetalnessMap.sampler);
            glUniform1i(result.fragment.uniforms.uNormalMap, (GLint)result.fragment.samplers.uNormalMap.sampler);
            glUseProgram(0);
        }
        return result;
    }

    ShaderInfo LoadShaders()
    {
        ShaderInfo info = {};
        info.PbrMesh = CompileProgram_PbrMesh();
        SOKO_ASSERT(info.PbrMesh.handle);
        return info;
    }
    

    void UnloadShaders(ShaderInfo* info)
    {
        if (info->PbrMesh.handle)
        {
            glDeleteShader(info->PbrMesh.handle);
            info->PbrMesh.handle = 0;
        }
    }

    const char* ShaderInfo::Info_PbrMesh::VertexSource = R"(

#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aUV;
layout (location = 3) in vec3 aTangent;

uniform mat4 uViewProjMatrix;
uniform mat4 uModelMatrix;
uniform mat3 uNormalMatrix;

out vec3 vFragPos;
out vec3 vNormal;
out vec2 vUV;
out mat3 vTBN;

void main()
{
    vec3 n = normalize(uNormalMatrix * aNormal);
    vec3 t = normalize(uNormalMatrix * aTangent);
    t = normalize(t - dot(t, n) * n);
    vec3 b = normalize(cross(n, t));
    mat3 tbn = mat3(t, b, n);

    gl_Position = uViewProjMatrix * uModelMatrix * vec4(aPos, 1.0f);
    vFragPos = (uModelMatrix * vec4(aPos, 1.0f)).xyz;
    vUV = aUV;
    vNormal = n;
    vTBN = tbn;
})";

    const char* ShaderInfo::Info_PbrMesh::FragmentSource = R"(

#version 330 core
out vec4 resultColor;

in vec3 vFragPos;
in vec3 vNormal;
in vec2 vUV;
in mat3 vTBN;

struct DirLight
{
    vec3 dir;
    vec3 color;
};

uniform DirLight uDirLight;
uniform vec3 uViewPos;

uniform samplerCube uIrradanceMap;
uniform samplerCube uEnviromentMap;
uniform sampler2D uBRDFLut;

uniform sampler2D uAlbedoMap;
uniform sampler2D uRoughnessMap;
uniform sampler2D uMetalnessMap;
uniform sampler2D uNormalMap;
//uniform sampler2D uAOMap;

uniform int uCustomMaterial;
uniform vec3 uCustomAlbedo;
uniform float uCustomRoughness, uCustomMetalness;
//uniform float uCustomMetalness;

uniform int uDebugF;
uniform int uDebugG;
uniform int uDebugD;
uniform int uDebugNormals;

uniform float uAO = 1.0f;

const float MAX_REFLECTION_LOD = 5.0f;

#define PI (3.14159265359)

vec3 FresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (vec3(1.0f) - F0) * pow(1.0f - cosTheta, 5.0f);
}

vec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0f - roughness), F0) - F0) * pow(1.0f - cosTheta, 5.0f);
}

float DistributionGGX(vec3 N, vec3 H, float a)
{
    float a4 = a * a * a * a;
    float NdotH = max(dot(N, H), 0.0f);
    float NdotHSq = NdotH * NdotH;

    float num = a4;
    float denom = (NdotHSq * (a4 - 1.0f) + 1.0f);
    denom = PI * denom * denom;

    return num / max(denom, 0.001f);
}

float GeometrySchlickGGX(float NdotV, float a)
{
    float k = ((a + 1.0f) * (a + 1.0f)) / 8.0f;

    float num = NdotV;
    float denom = NdotV * (1.0f - k) + k;

    return num / denom;
}

float GeometrySmith(float NdotV, float NdotL, float a)
{
    float ggx1 = GeometrySchlickGGX(NdotV, a);
    float ggx2 = GeometrySchlickGGX(NdotL, a);

    return ggx1 * ggx2;
}

vec3 IBLIrradance(vec3 Vo, vec3 N, float NdotV, float a, vec3 F0, float metallic, vec3 albedo)
{
    // NOTE: Specular irradance
    vec3 R = reflect(-Vo, N);
    vec3 envIrradance = textureLod(uEnviromentMap, R, a * MAX_REFLECTION_LOD).rgb;
    vec3 Fenv = FresnelSchlickRoughness(NdotV, F0, a);
    vec2 envBRDF = texture(uBRDFLut, vec2(NdotV, a)).rg;
    vec3 envSpecular = envIrradance * (Fenv * envBRDF.r + envBRDF.g);

    // NOTE: Diffuse irradance
    vec3 kS = FresnelSchlick(NdotV, F0);
    vec3 kD = vec3(1.0f) - kS;
    kD *= 1.0f - metallic;
    vec3 diffIrradance = texture(uIrradanceMap, N).rgb;
    vec3 diffuse = diffIrradance * albedo;

    vec3 irradance = (kD * diffuse + envSpecular) * uAO;
    return irradance;
}

void main()
{
    vec3 N;
    vec3 albedo;
    float roughness;
    float metalness;

    if (uCustomMaterial == 1)
    {
        N = normalize(vNormal);
        albedo = uCustomAlbedo;
        roughness = uCustomRoughness;
        metalness = uCustomMetalness;
    }
    else
    {
         N = normalize(texture(uNormalMap, vUV).xyz * 2.0f - 1.0f);
         // NOTE: Flipping y because engine uses LH normal maps (UE4) but OpenGL does it's job in RH space
         N.y = -N.y;
         N = normalize(vTBN * N);
         albedo = texture(uAlbedoMap, vUV).xyz;
         roughness = texture(uRoughnessMap, vUV).r;
         metalness = texture(uMetalnessMap, vUV).r;
    }

    vec3 V = normalize(uViewPos - vFragPos);
    vec3 L0 = vec3(0.0f);

    vec3 L = normalize(-uDirLight.dir);
    vec3 H = normalize(V + L);

    // TODO: Adding this to avoid artifacts on edges
    // Why this value so big?
    float NdotV = max(dot(N, V), 0.0f);// + 0.000001f; // NOTE: Adding this value (trick from epic games shaders) reduces artifacts on the edges in Intel gpu's but completely brokes everything on nvidia
    float NdotL = max(dot(N, L), 0.0f);

    // NOTE: Attenuation should be here
    vec3 radiance = uDirLight.color;

    vec3 F0 = vec3(0.04f);
    F0 = mix(F0, albedo, metalness);

    // NOTE: Seems like it prodices visually incorrect result with H vector
    // and N gives more Fresnel-look-like result
    // but in papers people usually use H
    vec3 F = FresnelSchlick(max(dot(H, V), 0.0f), F0);
    float D = DistributionGGX(N, H, roughness);
    float G = GeometrySmith(NdotV, NdotL, roughness);

    vec3 num = D * G * F;
    float denom = 4.0f * NdotV * NdotL;;
    vec3 specular = num / max(denom, 0.001f);

    {
        vec3 kS = F;
        vec3 kD = vec3(1.0f) - kS;
        kD *= 1.0f - metalness;
        L0 += (kD * albedo / PI + specular) * radiance * NdotL;
    }

    vec3 envIrradance = IBLIrradance(V, N, NdotV, roughness, F0, metalness, albedo);

    resultColor = vec4((envIrradance + L0), 1.0f);

    if (uDebugF == 1) resultColor = vec4(F,  1.0f);
    else if (uDebugG == 1) resultColor = vec4(G, G, G, 1.0f);
    else if (uDebugD == 1) resultColor = vec4(D, D, D, 1.0f);
    else if (uDebugNormals == 1) resultColor = vec4(N, 1.0f);
})";

}
