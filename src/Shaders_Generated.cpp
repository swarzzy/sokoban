// Thise file was generated by a glsl preprocessor

namespace soko
{
    struct ShaderInfo
    {
        struct Info_PbrMesh
        {
            static const char* VertexSource;
            static const char* FragmentSource;
            
            GLuint handle;
            
            struct VertexShader
            {
                struct Uniforms
                {
                    GLint uViewProjMatrix;
                    GLint uModelMatrix;
                    GLint uNormalMatrix;
                } uniforms;

                struct VertexAttribs
                {
                    GLuint aPos = 0;
                    GLuint aNormal = 1;
                    GLuint aUV = 2;
                    GLuint aTangent = 3;
                } vertexAttribs;

            } vertex;

            struct FragmentShader
            {
                struct DirLight
                {
                    GLint dir;
                    GLint color;
                };

                struct Uniforms
                {
                    DirLight uDirLight;
                    GLint uViewPos;
                    GLint uIrradanceMap;
                    GLint uEnviromentMap;
                    GLint uBRDFLut;
                    GLint uAlbedoMap;
                    GLint uRoughnessMap;
                    GLint uMetalnessMap;
                    GLint uNormalMap;
                    GLint uCustomMaterial;
                    GLint uCustomAlbedo;
                    GLint uCustomRoughness;
                    GLint uCustomMetalness;
                    GLint uDebugF;
                    GLint uDebugG;
                    GLint uDebugD;
                    GLint uDebugNormals;
                    GLint uAO;
                } uniforms;

                struct Samplers
                {
                    Sampler uIrradanceMap = { 0, GL_TEXTURE0 };
                    Sampler uEnviromentMap = { 1, GL_TEXTURE1 };
                    Sampler uBRDFLut = { 2, GL_TEXTURE2 };
                    Sampler uAlbedoMap = { 3, GL_TEXTURE3 };
                    Sampler uRoughnessMap = { 4, GL_TEXTURE4 };
                    Sampler uMetalnessMap = { 5, GL_TEXTURE5 };
                    Sampler uNormalMap = { 6, GL_TEXTURE6 };
                } samplers;

            } fragment;

        } PbrMesh;

        struct Info_BRDFIntegrator
        {
            static const char* VertexSource;
            static const char* FragmentSource;
            
            GLuint handle;
            
            struct VertexShader
            {
                struct Uniforms
                {
                } uniforms;

                struct VertexAttribs
                {
                } vertexAttribs;

            } vertex;

            struct FragmentShader
            {
                struct Uniforms
                {
                } uniforms;

                struct Samplers
                {
                } samplers;

            } fragment;

        } BRDFIntegrator;

        struct Info_EnvMapPrefilter
        {
            static const char* VertexSource;
            static const char* FragmentSource;
            
            GLuint handle;
            
            struct VertexShader
            {
                struct Uniforms
                {
                    GLint u_ViewMatrix;
                    GLint u_ProjMatrix;
                } uniforms;

                struct VertexAttribs
                {
                } vertexAttribs;

            } vertex;

            struct FragmentShader
            {
                struct Uniforms
                {
                    GLint uSourceCubemap;
                    GLint uRoughness;
                    GLint uResolution;
                } uniforms;

                struct Samplers
                {
                    Sampler uSourceCubemap = { 0, GL_TEXTURE0 };
                } samplers;

            } fragment;

        } EnvMapPrefilter;

        struct Info_IrradanceConvolver
        {
            static const char* VertexSource;
            static const char* FragmentSource;
            
            GLuint handle;
            
            struct VertexShader
            {
                struct Uniforms
                {
                    GLint u_ViewMatrix;
                    GLint u_ProjMatrix;
                } uniforms;

                struct VertexAttribs
                {
                } vertexAttribs;

            } vertex;

            struct FragmentShader
            {
                struct Uniforms
                {
                    GLint uSourceCubemap;
                } uniforms;

                struct Samplers
                {
                    Sampler uSourceCubemap = { 0, GL_TEXTURE0 };
                } samplers;

            } fragment;

        } IrradanceConvolver;

        struct Info_FXAA
        {
            static const char* VertexSource;
            static const char* FragmentSource;
            
            GLuint handle;
            
            struct VertexShader
            {
                struct Uniforms
                {
                } uniforms;

                struct VertexAttribs
                {
                } vertexAttribs;

            } vertex;

            struct FragmentShader
            {
                struct Uniforms
                {
                    GLint u_ColorSourcePerceptual;
                    GLint u_InvScreenSize;
                } uniforms;

                struct Samplers
                {
                    Sampler u_ColorSourcePerceptual = { 0, GL_TEXTURE0 };
                } samplers;

            } fragment;

        } FXAA;

        struct Info_PostFX
        {
            static const char* VertexSource;
            static const char* FragmentSource;
            
            GLuint handle;
            
            struct VertexShader
            {
                struct Uniforms
                {
                } uniforms;

                struct VertexAttribs
                {
                } vertexAttribs;

            } vertex;

            struct FragmentShader
            {
                struct Uniforms
                {
                    GLint u_Gamma;
                    GLint u_Exposure;
                    GLint u_ColorSourceLinear;
                } uniforms;

                struct Samplers
                {
                    Sampler u_ColorSourceLinear = { 0, GL_TEXTURE0 };
                } samplers;

            } fragment;

        } PostFX;

        struct Info_Skybox
        {
            static const char* VertexSource;
            static const char* FragmentSource;
            
            GLuint handle;
            
            struct VertexShader
            {
                struct Uniforms
                {
                    GLint u_ViewMatrix;
                    GLint u_ProjMatrix;
                } uniforms;

                struct VertexAttribs
                {
                } vertexAttribs;

            } vertex;

            struct FragmentShader
            {
                struct Uniforms
                {
                    GLint uLod;
                    GLint u_CubeTexture;
                } uniforms;

                struct Samplers
                {
                    Sampler u_CubeTexture = { 0, GL_TEXTURE0 };
                } samplers;

            } fragment;

        } Skybox;

        struct Info_Line
        {
            static const char* VertexSource;
            static const char* FragmentSource;
            
            GLuint handle;
            
            struct VertexShader
            {
                struct Uniforms
                {
                    GLint u_ViewProjMatrix;
                    GLint u_Color;
                } uniforms;

                struct VertexAttribs
                {
                    GLuint v_Pos = 0;
                } vertexAttribs;

            } vertex;

            struct FragmentShader
            {
                struct Uniforms
                {
                } uniforms;

                struct Samplers
                {
                } samplers;

            } fragment;

        } Line;

        struct Info_Mesh
        {
            static const char* VertexSource;
            static const char* FragmentSource;
            
            GLuint handle;
            
            struct VertexShader
            {
                struct Uniforms
                {
                    GLint u_ViewProjMatrix;
                    GLint u_ModelMatrix;
                    GLint u_NormalMatrix;
                } uniforms;

                struct VertexAttribs
                {
                    GLuint attr_Pos = 0;
                    GLuint attr_Normal = 1;
                    GLuint attr_UV = 2;
                } vertexAttribs;

            } vertex;

            struct FragmentShader
            {
                struct DirLight
                {
                    GLint dir;
                    GLint ambient;
                    GLint diffuse;
                    GLint specular;
                };

                struct Uniforms
                {
                    DirLight u_DirLight;
                    GLint u_ViewPos;
                    GLint u_DiffMap;
                    GLint u_SpecMap;
                } uniforms;

                struct Samplers
                {
                    Sampler u_DiffMap = { 0, GL_TEXTURE0 };
                    Sampler u_SpecMap = { 1, GL_TEXTURE1 };
                } samplers;

            } fragment;

        } Mesh;

        struct Info_Chunk
        {
            static const char* VertexSource;
            static const char* FragmentSource;
            
            GLuint handle;
            
            struct VertexShader
            {
                struct Uniforms
                {
                    GLint u_ModelMatrix;
                    GLint u_NormalMatrix;
                    GLint u_ViewMatrix;
                    GLint u_ProjectionMatrix;
                    GLint u_LightSpaceMatrix[3];
                } uniforms;

                struct VertexAttribs
                {
                    GLuint a_Position = 0;
                    GLuint a_Normal = 1;
                    GLuint a_TileId = 2;
                } vertexAttribs;

            } vertex;

            struct FragmentShader
            {
                struct DirLight
                {
                    GLint dir;
                    GLint ambient;
                    GLint diffuse;
                    GLint specular;
                };

                struct Uniforms
                {
                    DirLight u_DirLight;
                    GLint u_ViewPos;
                    GLint u_TerrainAtlas;
                    GLint u_ShadowMap;
                    GLint u_ShadowCascadeSplits;
                    GLint u_ShowShadowCascadesBoundaries;
                    GLint shadowFilterSampleScale;
                    GLint randomTexture;
                } uniforms;

                struct Samplers
                {
                    Sampler u_TerrainAtlas = { 1, GL_TEXTURE1 };
                    Sampler u_ShadowMap = { 4, GL_TEXTURE4 };
                    Sampler randomTexture = { 5, GL_TEXTURE5 };
                } samplers;

            } fragment;

        } Chunk;

        struct Info_Shadow
        {
            static const char* VertexSource;
            static const char* FragmentSource;
            
            GLuint handle;
            
            struct VertexShader
            {
                struct Uniforms
                {
                    GLint ModelMatrix;
                    GLint ViewProjMatrix;
                    GLint NormalMatrix;
                    GLint LightPos;
                    GLint ShadowNormalBiasScale;
                } uniforms;

                struct VertexAttribs
                {
                    GLuint Position = 0;
                    GLuint Normal = 1;
                } vertexAttribs;

            } vertex;

            struct FragmentShader
            {
                struct Uniforms
                {
                    GLint ConstantShadowBias;
                } uniforms;

                struct Samplers
                {
                } samplers;

            } fragment;

        } Shadow;

    };

    ShaderInfo::Info_PbrMesh CompileProgram_PbrMesh()
    {
        ShaderInfo::Info_PbrMesh result = {};
        auto handle = CreateProgram(ShaderInfo::Info_PbrMesh::VertexSource, ShaderInfo::Info_PbrMesh::FragmentSource);
        if (handle)
        {
            result.handle = handle;
            // NOTE: Assign vertex shader uniforms
            result.vertex.uniforms.uViewProjMatrix = glGetUniformLocation(handle, "uViewProjMatrix");
            result.vertex.uniforms.uModelMatrix = glGetUniformLocation(handle, "uModelMatrix");
            result.vertex.uniforms.uNormalMatrix = glGetUniformLocation(handle, "uNormalMatrix");

            // NOTE: Assign fragment shader uniforms
            result.fragment.uniforms.uDirLight.dir = glGetUniformLocation(handle, "uDirLight.dir");
            result.fragment.uniforms.uDirLight.color = glGetUniformLocation(handle, "uDirLight.color");
            result.fragment.uniforms.uViewPos = glGetUniformLocation(handle, "uViewPos");
            result.fragment.uniforms.uIrradanceMap = glGetUniformLocation(handle, "uIrradanceMap");
            result.fragment.uniforms.uEnviromentMap = glGetUniformLocation(handle, "uEnviromentMap");
            result.fragment.uniforms.uBRDFLut = glGetUniformLocation(handle, "uBRDFLut");
            result.fragment.uniforms.uAlbedoMap = glGetUniformLocation(handle, "uAlbedoMap");
            result.fragment.uniforms.uRoughnessMap = glGetUniformLocation(handle, "uRoughnessMap");
            result.fragment.uniforms.uMetalnessMap = glGetUniformLocation(handle, "uMetalnessMap");
            result.fragment.uniforms.uNormalMap = glGetUniformLocation(handle, "uNormalMap");
            result.fragment.uniforms.uCustomMaterial = glGetUniformLocation(handle, "uCustomMaterial");
            result.fragment.uniforms.uCustomAlbedo = glGetUniformLocation(handle, "uCustomAlbedo");
            result.fragment.uniforms.uCustomRoughness = glGetUniformLocation(handle, "uCustomRoughness");
            result.fragment.uniforms.uCustomMetalness = glGetUniformLocation(handle, "uCustomMetalness");
            result.fragment.uniforms.uDebugF = glGetUniformLocation(handle, "uDebugF");
            result.fragment.uniforms.uDebugG = glGetUniformLocation(handle, "uDebugG");
            result.fragment.uniforms.uDebugD = glGetUniformLocation(handle, "uDebugD");
            result.fragment.uniforms.uDebugNormals = glGetUniformLocation(handle, "uDebugNormals");
            result.fragment.uniforms.uAO = glGetUniformLocation(handle, "uAO");

            //NOTE: Setting samplers
            glUseProgram(handle);
            glUniform1i(result.fragment.uniforms.uIrradanceMap, (GLint)result.fragment.samplers.uIrradanceMap.sampler);
            glUniform1i(result.fragment.uniforms.uEnviromentMap, (GLint)result.fragment.samplers.uEnviromentMap.sampler);
            glUniform1i(result.fragment.uniforms.uBRDFLut, (GLint)result.fragment.samplers.uBRDFLut.sampler);
            glUniform1i(result.fragment.uniforms.uAlbedoMap, (GLint)result.fragment.samplers.uAlbedoMap.sampler);
            glUniform1i(result.fragment.uniforms.uRoughnessMap, (GLint)result.fragment.samplers.uRoughnessMap.sampler);
            glUniform1i(result.fragment.uniforms.uMetalnessMap, (GLint)result.fragment.samplers.uMetalnessMap.sampler);
            glUniform1i(result.fragment.uniforms.uNormalMap, (GLint)result.fragment.samplers.uNormalMap.sampler);
            glUseProgram(0);
        }
        return result;
    }

    ShaderInfo::Info_BRDFIntegrator CompileProgram_BRDFIntegrator()
    {
        ShaderInfo::Info_BRDFIntegrator result = {};
        auto handle = CreateProgram(ShaderInfo::Info_BRDFIntegrator::VertexSource, ShaderInfo::Info_BRDFIntegrator::FragmentSource);
        if (handle)
        {
            result.handle = handle;
            // NOTE: Assign vertex shader uniforms

            // NOTE: Assign fragment shader uniforms

            //NOTE: Setting samplers
            glUseProgram(handle);
            glUseProgram(0);
        }
        return result;
    }

    ShaderInfo::Info_EnvMapPrefilter CompileProgram_EnvMapPrefilter()
    {
        ShaderInfo::Info_EnvMapPrefilter result = {};
        auto handle = CreateProgram(ShaderInfo::Info_EnvMapPrefilter::VertexSource, ShaderInfo::Info_EnvMapPrefilter::FragmentSource);
        if (handle)
        {
            result.handle = handle;
            // NOTE: Assign vertex shader uniforms
            result.vertex.uniforms.u_ViewMatrix = glGetUniformLocation(handle, "u_ViewMatrix");
            result.vertex.uniforms.u_ProjMatrix = glGetUniformLocation(handle, "u_ProjMatrix");

            // NOTE: Assign fragment shader uniforms
            result.fragment.uniforms.uSourceCubemap = glGetUniformLocation(handle, "uSourceCubemap");
            result.fragment.uniforms.uRoughness = glGetUniformLocation(handle, "uRoughness");
            result.fragment.uniforms.uResolution = glGetUniformLocation(handle, "uResolution");

            //NOTE: Setting samplers
            glUseProgram(handle);
            glUniform1i(result.fragment.uniforms.uSourceCubemap, (GLint)result.fragment.samplers.uSourceCubemap.sampler);
            glUseProgram(0);
        }
        return result;
    }

    ShaderInfo::Info_IrradanceConvolver CompileProgram_IrradanceConvolver()
    {
        ShaderInfo::Info_IrradanceConvolver result = {};
        auto handle = CreateProgram(ShaderInfo::Info_IrradanceConvolver::VertexSource, ShaderInfo::Info_IrradanceConvolver::FragmentSource);
        if (handle)
        {
            result.handle = handle;
            // NOTE: Assign vertex shader uniforms
            result.vertex.uniforms.u_ViewMatrix = glGetUniformLocation(handle, "u_ViewMatrix");
            result.vertex.uniforms.u_ProjMatrix = glGetUniformLocation(handle, "u_ProjMatrix");

            // NOTE: Assign fragment shader uniforms
            result.fragment.uniforms.uSourceCubemap = glGetUniformLocation(handle, "uSourceCubemap");

            //NOTE: Setting samplers
            glUseProgram(handle);
            glUniform1i(result.fragment.uniforms.uSourceCubemap, (GLint)result.fragment.samplers.uSourceCubemap.sampler);
            glUseProgram(0);
        }
        return result;
    }

    ShaderInfo::Info_FXAA CompileProgram_FXAA()
    {
        ShaderInfo::Info_FXAA result = {};
        auto handle = CreateProgram(ShaderInfo::Info_FXAA::VertexSource, ShaderInfo::Info_FXAA::FragmentSource);
        if (handle)
        {
            result.handle = handle;
            // NOTE: Assign vertex shader uniforms

            // NOTE: Assign fragment shader uniforms
            result.fragment.uniforms.u_ColorSourcePerceptual = glGetUniformLocation(handle, "u_ColorSourcePerceptual");
            result.fragment.uniforms.u_InvScreenSize = glGetUniformLocation(handle, "u_InvScreenSize");

            //NOTE: Setting samplers
            glUseProgram(handle);
            glUniform1i(result.fragment.uniforms.u_ColorSourcePerceptual, (GLint)result.fragment.samplers.u_ColorSourcePerceptual.sampler);
            glUseProgram(0);
        }
        return result;
    }

    ShaderInfo::Info_PostFX CompileProgram_PostFX()
    {
        ShaderInfo::Info_PostFX result = {};
        auto handle = CreateProgram(ShaderInfo::Info_PostFX::VertexSource, ShaderInfo::Info_PostFX::FragmentSource);
        if (handle)
        {
            result.handle = handle;
            // NOTE: Assign vertex shader uniforms

            // NOTE: Assign fragment shader uniforms
            result.fragment.uniforms.u_Gamma = glGetUniformLocation(handle, "u_Gamma");
            result.fragment.uniforms.u_Exposure = glGetUniformLocation(handle, "u_Exposure");
            result.fragment.uniforms.u_ColorSourceLinear = glGetUniformLocation(handle, "u_ColorSourceLinear");

            //NOTE: Setting samplers
            glUseProgram(handle);
            glUniform1i(result.fragment.uniforms.u_ColorSourceLinear, (GLint)result.fragment.samplers.u_ColorSourceLinear.sampler);
            glUseProgram(0);
        }
        return result;
    }

    ShaderInfo::Info_Skybox CompileProgram_Skybox()
    {
        ShaderInfo::Info_Skybox result = {};
        auto handle = CreateProgram(ShaderInfo::Info_Skybox::VertexSource, ShaderInfo::Info_Skybox::FragmentSource);
        if (handle)
        {
            result.handle = handle;
            // NOTE: Assign vertex shader uniforms
            result.vertex.uniforms.u_ViewMatrix = glGetUniformLocation(handle, "u_ViewMatrix");
            result.vertex.uniforms.u_ProjMatrix = glGetUniformLocation(handle, "u_ProjMatrix");

            // NOTE: Assign fragment shader uniforms
            result.fragment.uniforms.uLod = glGetUniformLocation(handle, "uLod");
            result.fragment.uniforms.u_CubeTexture = glGetUniformLocation(handle, "u_CubeTexture");

            //NOTE: Setting samplers
            glUseProgram(handle);
            glUniform1i(result.fragment.uniforms.u_CubeTexture, (GLint)result.fragment.samplers.u_CubeTexture.sampler);
            glUseProgram(0);
        }
        return result;
    }

    ShaderInfo::Info_Line CompileProgram_Line()
    {
        ShaderInfo::Info_Line result = {};
        auto handle = CreateProgram(ShaderInfo::Info_Line::VertexSource, ShaderInfo::Info_Line::FragmentSource);
        if (handle)
        {
            result.handle = handle;
            // NOTE: Assign vertex shader uniforms
            result.vertex.uniforms.u_ViewProjMatrix = glGetUniformLocation(handle, "u_ViewProjMatrix");
            result.vertex.uniforms.u_Color = glGetUniformLocation(handle, "u_Color");

            // NOTE: Assign fragment shader uniforms

            //NOTE: Setting samplers
            glUseProgram(handle);
            glUseProgram(0);
        }
        return result;
    }

    ShaderInfo::Info_Mesh CompileProgram_Mesh()
    {
        ShaderInfo::Info_Mesh result = {};
        auto handle = CreateProgram(ShaderInfo::Info_Mesh::VertexSource, ShaderInfo::Info_Mesh::FragmentSource);
        if (handle)
        {
            result.handle = handle;
            // NOTE: Assign vertex shader uniforms
            result.vertex.uniforms.u_ViewProjMatrix = glGetUniformLocation(handle, "u_ViewProjMatrix");
            result.vertex.uniforms.u_ModelMatrix = glGetUniformLocation(handle, "u_ModelMatrix");
            result.vertex.uniforms.u_NormalMatrix = glGetUniformLocation(handle, "u_NormalMatrix");

            // NOTE: Assign fragment shader uniforms
            result.fragment.uniforms.u_DirLight.dir = glGetUniformLocation(handle, "u_DirLight.dir");
            result.fragment.uniforms.u_DirLight.ambient = glGetUniformLocation(handle, "u_DirLight.ambient");
            result.fragment.uniforms.u_DirLight.diffuse = glGetUniformLocation(handle, "u_DirLight.diffuse");
            result.fragment.uniforms.u_DirLight.specular = glGetUniformLocation(handle, "u_DirLight.specular");
            result.fragment.uniforms.u_ViewPos = glGetUniformLocation(handle, "u_ViewPos");
            result.fragment.uniforms.u_DiffMap = glGetUniformLocation(handle, "u_DiffMap");
            result.fragment.uniforms.u_SpecMap = glGetUniformLocation(handle, "u_SpecMap");

            //NOTE: Setting samplers
            glUseProgram(handle);
            glUniform1i(result.fragment.uniforms.u_DiffMap, (GLint)result.fragment.samplers.u_DiffMap.sampler);
            glUniform1i(result.fragment.uniforms.u_SpecMap, (GLint)result.fragment.samplers.u_SpecMap.sampler);
            glUseProgram(0);
        }
        return result;
    }

    ShaderInfo::Info_Chunk CompileProgram_Chunk()
    {
        ShaderInfo::Info_Chunk result = {};
        auto handle = CreateProgram(ShaderInfo::Info_Chunk::VertexSource, ShaderInfo::Info_Chunk::FragmentSource);
        if (handle)
        {
            result.handle = handle;
            // NOTE: Assign vertex shader uniforms
            result.vertex.uniforms.u_ModelMatrix = glGetUniformLocation(handle, "u_ModelMatrix");
            result.vertex.uniforms.u_NormalMatrix = glGetUniformLocation(handle, "u_NormalMatrix");
            result.vertex.uniforms.u_ViewMatrix = glGetUniformLocation(handle, "u_ViewMatrix");
            result.vertex.uniforms.u_ProjectionMatrix = glGetUniformLocation(handle, "u_ProjectionMatrix");
            result.vertex.uniforms.u_LightSpaceMatrix[0] = glGetUniformLocation(handle, "u_LightSpaceMatrix[0]");
            result.vertex.uniforms.u_LightSpaceMatrix[1] = glGetUniformLocation(handle, "u_LightSpaceMatrix[1]");
            result.vertex.uniforms.u_LightSpaceMatrix[2] = glGetUniformLocation(handle, "u_LightSpaceMatrix[2]");

            // NOTE: Assign fragment shader uniforms
            result.fragment.uniforms.u_DirLight.dir = glGetUniformLocation(handle, "u_DirLight.dir");
            result.fragment.uniforms.u_DirLight.ambient = glGetUniformLocation(handle, "u_DirLight.ambient");
            result.fragment.uniforms.u_DirLight.diffuse = glGetUniformLocation(handle, "u_DirLight.diffuse");
            result.fragment.uniforms.u_DirLight.specular = glGetUniformLocation(handle, "u_DirLight.specular");
            result.fragment.uniforms.u_ViewPos = glGetUniformLocation(handle, "u_ViewPos");
            result.fragment.uniforms.u_TerrainAtlas = glGetUniformLocation(handle, "u_TerrainAtlas");
            result.fragment.uniforms.u_ShadowMap = glGetUniformLocation(handle, "u_ShadowMap");
            result.fragment.uniforms.u_ShadowCascadeSplits = glGetUniformLocation(handle, "u_ShadowCascadeSplits");
            result.fragment.uniforms.u_ShowShadowCascadesBoundaries = glGetUniformLocation(handle, "u_ShowShadowCascadesBoundaries");
            result.fragment.uniforms.shadowFilterSampleScale = glGetUniformLocation(handle, "shadowFilterSampleScale");
            result.fragment.uniforms.randomTexture = glGetUniformLocation(handle, "randomTexture");

            //NOTE: Setting samplers
            glUseProgram(handle);
            glUniform1i(result.fragment.uniforms.u_TerrainAtlas, (GLint)result.fragment.samplers.u_TerrainAtlas.sampler);
            glUniform1i(result.fragment.uniforms.u_ShadowMap, (GLint)result.fragment.samplers.u_ShadowMap.sampler);
            glUniform1i(result.fragment.uniforms.randomTexture, (GLint)result.fragment.samplers.randomTexture.sampler);
            glUseProgram(0);
        }
        return result;
    }

    ShaderInfo::Info_Shadow CompileProgram_Shadow()
    {
        ShaderInfo::Info_Shadow result = {};
        auto handle = CreateProgram(ShaderInfo::Info_Shadow::VertexSource, ShaderInfo::Info_Shadow::FragmentSource);
        if (handle)
        {
            result.handle = handle;
            // NOTE: Assign vertex shader uniforms
            result.vertex.uniforms.ModelMatrix = glGetUniformLocation(handle, "ModelMatrix");
            result.vertex.uniforms.ViewProjMatrix = glGetUniformLocation(handle, "ViewProjMatrix");
            result.vertex.uniforms.NormalMatrix = glGetUniformLocation(handle, "NormalMatrix");
            result.vertex.uniforms.LightPos = glGetUniformLocation(handle, "LightPos");
            result.vertex.uniforms.ShadowNormalBiasScale = glGetUniformLocation(handle, "ShadowNormalBiasScale");

            // NOTE: Assign fragment shader uniforms
            result.fragment.uniforms.ConstantShadowBias = glGetUniformLocation(handle, "ConstantShadowBias");

            //NOTE: Setting samplers
            glUseProgram(handle);
            glUseProgram(0);
        }
        return result;
    }

    ShaderInfo LoadShaders()
    {
        ShaderInfo info = {};
        info.PbrMesh = CompileProgram_PbrMesh();
        if (!info.PbrMesh.handle) SOKO_WARN("ShaderManager: Failed to load shader program PbrMesh");
        info.BRDFIntegrator = CompileProgram_BRDFIntegrator();
        if (!info.BRDFIntegrator.handle) SOKO_WARN("ShaderManager: Failed to load shader program BRDFIntegrator");
        info.EnvMapPrefilter = CompileProgram_EnvMapPrefilter();
        if (!info.EnvMapPrefilter.handle) SOKO_WARN("ShaderManager: Failed to load shader program EnvMapPrefilter");
        info.IrradanceConvolver = CompileProgram_IrradanceConvolver();
        if (!info.IrradanceConvolver.handle) SOKO_WARN("ShaderManager: Failed to load shader program IrradanceConvolver");
        info.FXAA = CompileProgram_FXAA();
        if (!info.FXAA.handle) SOKO_WARN("ShaderManager: Failed to load shader program FXAA");
        info.PostFX = CompileProgram_PostFX();
        if (!info.PostFX.handle) SOKO_WARN("ShaderManager: Failed to load shader program PostFX");
        info.Skybox = CompileProgram_Skybox();
        if (!info.Skybox.handle) SOKO_WARN("ShaderManager: Failed to load shader program Skybox");
        info.Line = CompileProgram_Line();
        if (!info.Line.handle) SOKO_WARN("ShaderManager: Failed to load shader program Line");
        info.Mesh = CompileProgram_Mesh();
        if (!info.Mesh.handle) SOKO_WARN("ShaderManager: Failed to load shader program Mesh");
        info.Chunk = CompileProgram_Chunk();
        if (!info.Chunk.handle) SOKO_WARN("ShaderManager: Failed to load shader program Chunk");
        info.Shadow = CompileProgram_Shadow();
        if (!info.Shadow.handle) SOKO_WARN("ShaderManager: Failed to load shader program Shadow");
        return info;
    }
    

    void UnloadShaders(ShaderInfo* info)
    {
        glFinish();
        if (info->PbrMesh.handle)
        {
            glDeleteProgram(info->PbrMesh.handle);
            info->PbrMesh.handle = 0;
        }
        if (info->BRDFIntegrator.handle)
        {
            glDeleteProgram(info->BRDFIntegrator.handle);
            info->BRDFIntegrator.handle = 0;
        }
        if (info->EnvMapPrefilter.handle)
        {
            glDeleteProgram(info->EnvMapPrefilter.handle);
            info->EnvMapPrefilter.handle = 0;
        }
        if (info->IrradanceConvolver.handle)
        {
            glDeleteProgram(info->IrradanceConvolver.handle);
            info->IrradanceConvolver.handle = 0;
        }
        if (info->FXAA.handle)
        {
            glDeleteProgram(info->FXAA.handle);
            info->FXAA.handle = 0;
        }
        if (info->PostFX.handle)
        {
            glDeleteProgram(info->PostFX.handle);
            info->PostFX.handle = 0;
        }
        if (info->Skybox.handle)
        {
            glDeleteProgram(info->Skybox.handle);
            info->Skybox.handle = 0;
        }
        if (info->Line.handle)
        {
            glDeleteProgram(info->Line.handle);
            info->Line.handle = 0;
        }
        if (info->Mesh.handle)
        {
            glDeleteProgram(info->Mesh.handle);
            info->Mesh.handle = 0;
        }
        if (info->Chunk.handle)
        {
            glDeleteProgram(info->Chunk.handle);
            info->Chunk.handle = 0;
        }
        if (info->Shadow.handle)
        {
            glDeleteProgram(info->Shadow.handle);
            info->Shadow.handle = 0;
        }
    }

    const char* ShaderInfo::Info_PbrMesh::VertexSource = R"(#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aUV;
layout (location = 3) in vec3 aTangent;

uniform mat4 uViewProjMatrix;
uniform mat4 uModelMatrix;
uniform mat3 uNormalMatrix;

out vec3 vFragPos;
out vec3 vNormal;
out vec2 vUV;
out mat3 vTBN;

void main()
{
    vec3 n = normalize(uNormalMatrix * aNormal);
    vec3 t = normalize(uNormalMatrix * aTangent);
    t = normalize(t - dot(t, n) * n);
    vec3 b = normalize(cross(n, t));
    mat3 tbn = mat3(t, b, n);

    gl_Position = uViewProjMatrix * uModelMatrix * vec4(aPos, 1.0f);
    vFragPos = (uModelMatrix * vec4(aPos, 1.0f)).xyz;
    vUV = aUV;
    vNormal = n;
    vTBN = tbn;
})";

    const char* ShaderInfo::Info_PbrMesh::FragmentSource = R"(#version 330 core
out vec4 resultColor;

in vec3 vFragPos;
in vec3 vNormal;
in vec2 vUV;
in mat3 vTBN;

struct DirLight
{
    vec3 dir;
    vec3 color;
};

uniform DirLight uDirLight;
uniform vec3 uViewPos;

uniform samplerCube uIrradanceMap;
uniform samplerCube uEnviromentMap;
uniform sampler2D uBRDFLut;

uniform sampler2D uAlbedoMap;
uniform sampler2D uRoughnessMap;
uniform sampler2D uMetalnessMap;
uniform sampler2D uNormalMap;
//uniform sampler2D uAOMap;

uniform int uCustomMaterial;
uniform vec3 uCustomAlbedo;
uniform float uCustomRoughness;
uniform float uCustomMetalness;

uniform int uDebugF;
uniform int uDebugG;
uniform int uDebugD;
uniform int uDebugNormals;

uniform float uAO = 1.0f;

const float MAX_REFLECTION_LOD = 5.0f;

#define PI (3.14159265359)

vec3 FresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (vec3(1.0f) - F0) * pow(1.0f - cosTheta, 5.0f);
}

vec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0f - roughness), F0) - F0) * pow(1.0f - cosTheta, 5.0f);
}

float DistributionGGX(vec3 N, vec3 H, float a)
{
    float a4 = a * a * a * a;
    float NdotH = max(dot(N, H), 0.0f);
    float NdotHSq = NdotH * NdotH;

    float num = a4;
    float denom = (NdotHSq * (a4 - 1.0f) + 1.0f);
    denom = PI * denom * denom;

    return num / max(denom, 0.001f);
}

float GeometrySchlickGGX(float NdotV, float a)
{
    float k = ((a + 1.0f) * (a + 1.0f)) / 8.0f;

    float num = NdotV;
    float denom = NdotV * (1.0f - k) + k;

    return num / denom;
}

float GeometrySmith(float NdotV, float NdotL, float a)
{
    float ggx1 = GeometrySchlickGGX(NdotV, a);
    float ggx2 = GeometrySchlickGGX(NdotL, a);

    return ggx1 * ggx2;
}

vec3 IBLIrradance(vec3 Vo, vec3 N, float NdotV, float a, vec3 F0, float metallic, vec3 albedo)
{
    // NOTE: Specular irradance
    vec3 R = reflect(-Vo, N);
    vec3 envIrradance = textureLod(uEnviromentMap, R, a * MAX_REFLECTION_LOD).rgb;
    vec3 Fenv = FresnelSchlickRoughness(NdotV, F0, a);
    vec2 envBRDF = texture(uBRDFLut, vec2(NdotV, a)).rg;
    vec3 envSpecular = envIrradance * (Fenv * envBRDF.r + envBRDF.g);

    // NOTE: Diffuse irradance
    vec3 kS = FresnelSchlick(NdotV, F0);
    vec3 kD = vec3(1.0f) - kS;
    kD *= 1.0f - metallic;
    vec3 diffIrradance = texture(uIrradanceMap, N).rgb;
    vec3 diffuse = diffIrradance * albedo;

    vec3 irradance = (kD * diffuse + envSpecular) * uAO;
    return irradance;
}

void main()
{
    vec3 N;
    vec3 albedo;
    float roughness;
    float metalness;

    if (uCustomMaterial == 1)
    {
        N = normalize(vNormal);
        albedo = uCustomAlbedo;
        roughness = uCustomRoughness;
        metalness = uCustomMetalness;
    }
    else
    {
         N = normalize(texture(uNormalMap, vUV).xyz * 2.0f - 1.0f);
         // NOTE: Flipping y because engine uses LH normal maps (UE4) but OpenGL does it's job in RH space
         N.y = -N.y;
         N = normalize(vTBN * N);
         albedo = texture(uAlbedoMap, vUV).xyz;
         roughness = texture(uRoughnessMap, vUV).r;
         metalness = texture(uMetalnessMap, vUV).r;
    }

    vec3 V = normalize(uViewPos - vFragPos);
    vec3 L0 = vec3(0.0f);

    vec3 L = normalize(-uDirLight.dir);
    vec3 H = normalize(V + L);

    // TODO: Adding this to avoid artifacts on edges
    // Why this value so big?
    float NdotV = max(dot(N, V), 0.0f);// + 0.000001f; // NOTE: Adding this value (trick from epic games shaders) reduces artifacts on the edges in Intel gpu's but completely brokes everything on nvidia
    float NdotL = max(dot(N, L), 0.0f);

    // NOTE: Attenuation should be here
    vec3 radiance = uDirLight.color;

    vec3 F0 = vec3(0.04f);
    F0 = mix(F0, albedo, metalness);

    // NOTE: Seems like it prodices visually incorrect result with H vector
    // and N gives more Fresnel-look-like result
    // but in papers people usually use H
    vec3 F = FresnelSchlick(max(dot(H, V), 0.0f), F0);
    float D = DistributionGGX(N, H, roughness);
    float G = GeometrySmith(NdotV, NdotL, roughness);

    vec3 num = D * G * F;
    float denom = 4.0f * NdotV * NdotL;;
    vec3 specular = num / max(denom, 0.001f);

    {
        vec3 kS = F;
        vec3 kD = vec3(1.0f) - kS;
        kD *= 1.0f - metalness;
        L0 += (kD * albedo / PI + specular) * radiance * NdotL;
    }

    vec3 envIrradance = IBLIrradance(V, N, NdotV, roughness, F0, metalness, albedo);

    resultColor = vec4((envIrradance + L0), 1.0f);

    if (uDebugF == 1) resultColor = vec4(F,  1.0f);
    else if (uDebugG == 1) resultColor = vec4(G, G, G, 1.0f);
    else if (uDebugD == 1) resultColor = vec4(D, D, D, 1.0f);
    else if (uDebugNormals == 1) resultColor = vec4(N, 1.0f);
})";

    const char* ShaderInfo::Info_BRDFIntegrator::VertexSource = R"(#version 330 core
vec2 VERTICES[] = vec2[](vec2(-1.0f, -1.0f),
                         vec2(1.0f, -1.0f),
                         vec2(1.0f, 1.0f),
                         vec2(1.0f, 1.0f),
                         vec2(-1.0f, 1.0f),
                         vec2(-1.0f, -1.0f));
out vec2 v_UV;

void main()
{
    vec4 vertexPos = vec4(VERTICES[min(gl_VertexID, 6)], 0.0f, 1.0f);
    gl_Position = vertexPos;
    v_UV = vertexPos.xy / 2.0f + 0.5f;
})";

    const char* ShaderInfo::Info_BRDFIntegrator::FragmentSource = R"(#version 330 core

in vec2 v_UV;
out vec4 ResultColor;

const uint SAMPLE_COUNT = 1024u;

const float PI_32 = 3.14159265358979323846f;

// NOTE: http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
float RadicalInverse_VdC(uint bits)
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10;
}

vec2 Hammersley(uint i, uint n)
{
    return vec2(float(i) / float(n), RadicalInverse_VdC(i));
}

vec3 ImportanceSampleGGX(vec2 p, vec3 N, float a)
{
    // NOTE: Epic Games GGX
    float aSq = a * a;
    float phi = 2.0f * PI_32 * p.x;
    float cosTheta = sqrt((1.0f - p.y) / (1.0f + (aSq * aSq - 1.0f) * p.y));
    float sinTheta = sqrt(1.0f - cosTheta * cosTheta);

    // NOTE: To cartesian
    vec3 d;
    d.x = cos(phi) * sinTheta;
    d.y = sin(phi) * sinTheta;
    d.z = cosTheta;

    // NOTE: From tangent space to world
    vec3 up = abs(N.z) < 0.999f ? vec3(0.0f, 0.0f, 1.0f) : vec3(1.0f, 0.0f, 0.0f); // ?????
    vec3 right = normalize(cross(up, N));
    up = cross(N, right);

    vec3 sampleVec = right * d.x + up * d.y + N * d.z;
    return normalize(sampleVec);
}

float GeometrySchlickGGX(float NdotV, float a)
{
    float k = (a * a) / 1.0f;
    float nom = NdotV;
    float denom = NdotV * (1.0f - k) + k;
    return nom / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float a)
{
    float NdotV = max(dot(N, V), 0.0f);
    float NdotL = max(dot(N, L), 0.0f);
    float ggx2 = GeometrySchlickGGX(NdotV, a);
    float ggx1 = GeometrySchlickGGX(NdotL, a);
    return ggx1 * ggx2;
}

vec2 IntegrateBRDF(float NdotV, float roughness)
{
    vec3 V;
    V.x = sqrt(1.0f - NdotV * NdotV);
    V.y = 0.0f;
    V.z = NdotV;

    float A = 0.0f;
    float B = 0.0f;

    vec3 N = vec3(0.0f, 0.0f, 1.0f);

    for (uint i = 0u; i < SAMPLE_COUNT; i++)
    {
        vec2 Xi = Hammersley(i, SAMPLE_COUNT);
        vec3 H = ImportanceSampleGGX(Xi, N, roughness);
        vec3 L = normalize(2.0f * dot(V, H) * H - V);

        float NdotL = max(L.z, 0.0f);
        float NdotH = max(H.z, 0.0f);
        float VdotH = max(dot(V, H), 0.0f);

        if (NdotL > 0.0f)
        {
            float G = GeometrySmith(N, V, L, roughness);
            float G_Vis = (G * VdotH) / (NdotH * NdotV);
            float Fc = pow(1.0f - VdotH, 5.0f);

            A += (1.0f - Fc) * G_Vis;
            B += Fc * G_Vis;
        }
    }
    A /= float(SAMPLE_COUNT);
    B /= float(SAMPLE_COUNT);

    return vec2(A, B);
}

void main()
{
    ResultColor = vec4(IntegrateBRDF(v_UV.x, v_UV.y), 0.0f, 1.0f);
})";

    const char* ShaderInfo::Info_EnvMapPrefilter::VertexSource = R"(#version 330 core

uniform mat4 u_ViewMatrix;
uniform mat4 u_ProjMatrix;

out vec3 v_UV;

vec2 VERTICES[] = vec2[](vec2(-1.0f, -1.0f),
                         vec2(1.0f, -1.0f),
                         vec2(1.0f, 1.0f),
                         vec2(1.0f, 1.0f),
                         vec2(-1.0f, 1.0f),
                         vec2(-1.0f, -1.0f));

void main()
{
    vec4 vertexPos = vec4(VERTICES[min(gl_VertexID, 6)], 0.0f, 1.0f);
    gl_Position = vertexPos;
    gl_Position = gl_Position.xyww;
    v_UV = mat3(inverse(u_ViewMatrix)) * (inverse(u_ProjMatrix) * gl_Position).xyz;
    //v_UV = (gl_Position * inverse(u_ViewMatrix) * inverse(u_ProjMatrix)).xyz;
})";

    const char* ShaderInfo::Info_EnvMapPrefilter::FragmentSource = R"(#version 330 core

in vec3 v_UV;
out vec4 resultColor;

uniform samplerCube uSourceCubemap;
uniform float uRoughness;
uniform int uResolution;

const float PI_32 = 3.14159265358979323846f;

// NOTE: http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
float RadicalInverse_VdC(uint bits)
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10;
}

vec2 Hammersley(uint i, uint n)
{
    return vec2(float(i) / float(n), RadicalInverse_VdC(i));
}

vec3 ImportanceSampleGGX(vec2 p, vec3 N, float a)
{
    // NOTE: Epic Games GGX
    float aSq = a * a;
    float phi = 2.0f * PI_32 * p.x;
    float cosTheta = sqrt((1.0f - p.y) / (1.0f + (aSq * aSq - 1.0f) * p.y));
    float sinTheta = sqrt(1.0f - cosTheta * cosTheta);

    // NOTE: To cartesian
    vec3 d;
    d.x = cos(phi) * sinTheta;
    d.y = sin(phi) * sinTheta;
    d.z = cosTheta;

    // NOTE: From tangent space to world
    vec3 up = abs(N.z) < 0.999f ? vec3(0.0f, 0.0f, 1.0f) : vec3(1.0f, 0.0f, 0.0f); // ?????
    vec3 right = normalize(cross(up, N));
    up = cross(N, right);

    vec3 sampleVec = right * d.x + up * d.y + N * d.z;
    return normalize(sampleVec);
}

float DistributionGGX(vec3 N, vec3 H, float a)
{
    float a4 = a * a * a * a;
    float NdotH = max(dot(N, H), 0.0f);
    float NdotHSq = NdotH * NdotH;

    float num = a4;
    float denom = (NdotHSq * (a4 - 1.0f) + 1.0f);
    denom = PI_32 * denom * denom;

    return num / max(denom, 0.001f);
}

const uint SAMPLES = 4096u;

void main()
{
    vec3 N = normalize(v_UV);
    vec3 R = N;
    vec3 V = R;

    float totalWeight = 0.0f;
    vec3 prefColor = vec3(0.0f);

    for (uint i = 0u; i < SAMPLES; i++)
    {
        vec2 p = Hammersley(i, SAMPLES);
        vec3 H = ImportanceSampleGGX(p, N, uRoughness);
        vec3 L = normalize(2.0f * dot(V, H) * H - V);

        float NdotL = max(dot(N, L), 0.0f);
        if (NdotL > 0.0f)
        {
            float D = DistributionGGX(N, H, uRoughness);
            float NdotH = max(dot(N, H), 0.0f);
            float HdotV = max(dot(H, V), 0.0f);
            float PDF = D * NdotH / (4.0f * HdotV) + 0.0001;
            float saTexel = 4.0f * PI_32 / (6.0f * uResolution * uResolution);
            float saSample = 1.0f / (float(SAMPLES) * PDF + 0.0001f);
            float mipLevel = uRoughness == 0.0f ? 0.0f : 0.5f * log2(saSample / saTexel);
            prefColor += textureLod(uSourceCubemap, L, mipLevel).rgb * NdotL;
            totalWeight += NdotL;
        }
    }

    prefColor = prefColor / totalWeight;

    resultColor = vec4(prefColor, 1.0f);
})";

    const char* ShaderInfo::Info_IrradanceConvolver::VertexSource = R"(#version 330 core

uniform mat4 u_ViewMatrix;
uniform mat4 u_ProjMatrix;

out vec3 v_UV;

vec2 VERTICES[] = vec2[](vec2(-1.0f, -1.0f),
                         vec2(1.0f, -1.0f),
                         vec2(1.0f, 1.0f),
                         vec2(1.0f, 1.0f),
                         vec2(-1.0f, 1.0f),
                         vec2(-1.0f, -1.0f));

void main()
{
    vec4 vertexPos = vec4(VERTICES[min(gl_VertexID, 6)], 0.0f, 1.0f);
    gl_Position = vertexPos;
    gl_Position = gl_Position.xyww;
    v_UV = mat3(inverse(u_ViewMatrix)) * (inverse(u_ProjMatrix) * gl_Position).xyz;
    //v_UV = (gl_Position * inverse(u_ViewMatrix) * inverse(u_ProjMatrix)).xyz;
})";

    const char* ShaderInfo::Info_IrradanceConvolver::FragmentSource = R"(#version 330 core

in vec3 v_UV;
out vec4 resultColor;

uniform samplerCube uSourceCubemap;

const float PI_32 = 3.14159265358979323846f;

void main()
{
    vec3 normal = normalize(v_UV);
    vec3 irradance = vec3(0.0f);

    vec3 up = vec3(0.0f, 1.0f, 0.0f);
    vec3 right = cross(up, normal);
    up = cross(normal, right);

    float sampleDelta = 0.025f;
    int sampleCount = 0;
    for (float phi = 0.0f; phi < (2.0f * PI_32); phi += sampleDelta)
    {
        for (float theta = 0.0f; theta < (0.5f * PI_32); theta += sampleDelta)
        {
            vec3 tgSample = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
            vec3 sampleDir = tgSample.x * right + tgSample.y * up + tgSample.z * normal;
            irradance += texture(uSourceCubemap, sampleDir).xyz * cos(theta) * sin(theta);
            sampleCount++;
        }
    }

    irradance = PI_32 * irradance * (1.0f / float(sampleCount));

    resultColor = vec4(irradance, 1.0f);
})";

    const char* ShaderInfo::Info_FXAA::VertexSource = R"(#version 330 core
vec2 VERTICES[] = vec2[](vec2(-1.0f, -1.0f),
                         vec2(1.0f, -1.0f),
                         vec2(1.0f, 1.0f),
                         vec2(1.0f, 1.0f),
                         vec2(-1.0f, 1.0f),
                         vec2(-1.0f, -1.0f));
out vec2 v_UV;

void main()
{
    vec4 vertexPos = vec4(VERTICES[min(gl_VertexID, 6)], 0.0f, 1.0f);
    gl_Position = vertexPos;
    v_UV = vertexPos.xy / 2.0f + 0.5f;
})";

    const char* ShaderInfo::Info_FXAA::FragmentSource = R"(#version 330 core
in vec2 v_UV;
out vec4 fragColorResult;

uniform sampler2D u_ColorSourcePerceptual;
uniform vec2 u_InvScreenSize;

float Luma(vec3 rgb)
{
    float result = dot(rgb, vec3(0.299f, 0.587f, 0.114f));
    return result;
}

#define EDGE_MIN_THRESHOLD 0.0625f  //0.0312f
#define EDGE_MAX_THRESHOLD 0.0625f  //0.125f
#define ITERATIONS 12
#define SUBPIXEL_QUALITY 0.75f

float STEPS[6] = float[](1.0f, 1.5f, 2.0f, 2.0f, 2.0f, 8.0f);
#define QUALITY(i) (STEPS[min(0, max(5, i))])

void main()
{
    // STUDY: Dependent texture reads
    vec3 sampleCenter = texture(u_ColorSourcePerceptual, v_UV).xyz;

    float lumaCenter = Luma(sampleCenter);
    float lumaDown = Luma(textureOffset(u_ColorSourcePerceptual, v_UV, ivec2(0, -1)).xyz);
    float lumaUp = Luma(textureOffset(u_ColorSourcePerceptual, v_UV, ivec2(0, 1)).xyz);
    float lumaLeft = Luma(textureOffset(u_ColorSourcePerceptual, v_UV, ivec2(-1, 0)).xyz);
    float lumaRight = Luma(textureOffset(u_ColorSourcePerceptual, v_UV, ivec2(1, 0)).xyz);

    float lumaMin = min(lumaCenter, min(min(lumaDown, lumaUp), min(lumaLeft, lumaRight)));
    float lumaMax = max(lumaCenter, max(max(lumaDown, lumaUp), max(lumaLeft, lumaRight)));
    float lumaRange = lumaMax - lumaMin;

    if (lumaRange >= max(EDGE_MIN_THRESHOLD, lumaMax * EDGE_MAX_THRESHOLD))
    {
        float lumaDownLeft = Luma(textureOffset(u_ColorSourcePerceptual, v_UV, ivec2(-1, -1)).xyz);
        float lumaUpRight = Luma(textureOffset(u_ColorSourcePerceptual, v_UV, ivec2(1, 1)).xyz);
        float lumaUpLeft = Luma(textureOffset(u_ColorSourcePerceptual, v_UV, ivec2(-1, 1)).xyz);
        float lumaDownRight = Luma(textureOffset(u_ColorSourcePerceptual, v_UV, ivec2(1, -1)).xyz);

        float lumaDownUp = lumaDown + lumaUp;
        float lumaLeftRight = lumaLeft + lumaRight;
        float lumaLeftCorners = lumaDownLeft + lumaUpLeft;
        float lumaDownCorners = lumaDownLeft + lumaDownRight;
        float lumaRightCorners = lumaDownRight + lumaUpRight;
        float lumaUpCorners = lumaUpRight + lumaUpLeft;

        float gradH = abs(-2.0f * lumaLeft + lumaLeftCorners) + abs(-2.0f * lumaCenter + lumaDownUp) * 2.0f + abs(-2.0 * lumaRight + lumaRightCorners);
        float gradV = abs(-2.0f * lumaUp + lumaUpCorners) + abs(-2.0f * lumaCenter + lumaLeftRight) * 2.0f + abs(-2.0f * lumaDown + lumaDownCorners);
        bool isHorizontal = (gradH >= gradV);

        float luma1 = isHorizontal ? lumaDown : lumaLeft;
        float luma2 = isHorizontal ? lumaUp : lumaRight;
        float grad1 = abs(luma1 - lumaCenter);
        float grad2 = abs(luma2 - lumaCenter);
        bool is1Steepest = grad1 >= grad2;
        float gradScaled = 0.25f * max(grad1, grad2);

        // TODO: dFdx() dFdy() ?
        float stepLength = isHorizontal ? u_InvScreenSize.y : u_InvScreenSize.x;
        float lumaLocalAvg = 0.0f;
        if (is1Steepest)
        {
            stepLength = -stepLength;
            lumaLocalAvg = 0.5f * (luma1 + lumaCenter);
        }
        else
        {
            lumaLocalAvg = 0.5f * (luma2 + lumaCenter);
        }

        vec2 currUV = v_UV;
        isHorizontal ? (currUV.y = currUV.y + stepLength * 0.5f) : (currUV.x = currUV.x + stepLength * 0.5f);

        vec2 offset = isHorizontal ? vec2(u_InvScreenSize.x, 0.0f) : vec2(0.0f, u_InvScreenSize.y);
        vec2 uv1 = currUV - offset;
        vec2 uv2 = currUV + offset;

        float lumaEnd1 = Luma(texture(u_ColorSourcePerceptual, uv1).xyz);
        float lumaEnd2 = Luma(texture(u_ColorSourcePerceptual, uv2).xyz);
        lumaEnd1 -= lumaLocalAvg;
        lumaEnd2 -= lumaLocalAvg;
        bool reached1 = abs(lumaEnd1) >= gradScaled;
        bool reached2 = abs(lumaEnd2) >= gradScaled;
        bool reachedBoth = reached1 && reached2;
        if (!reached1) uv1 -= offset;
        if (!reached2) uv2 += offset;

        if (!reachedBoth)
        {
            for (int i = 1; i < ITERATIONS; i++)
            {
                if (!reached1)
                {
                    lumaEnd1 = Luma(texture(u_ColorSourcePerceptual, uv1).xyz);
                    lumaEnd1 -= lumaLocalAvg;
                }
                if (!reached2)
                {
                    lumaEnd2 = Luma(texture(u_ColorSourcePerceptual, uv2).xyz);
                    lumaEnd2 -= lumaLocalAvg;
                }
                reached1 = abs(lumaEnd1) >= gradScaled;
                reached2 = abs(lumaEnd2) >= gradScaled;
                reachedBoth = reached1 && reached2;
                if (!reached1) uv1 -= offset * QUALITY(i);
                if (!reached2) uv2 += offset * QUALITY(i);
                if (reachedBoth) break;
            }
        }

        float dist1 = isHorizontal ? (v_UV.x - uv1.x) : (v_UV.y - uv1.y);
        float dist2 = isHorizontal ? (uv2.x - v_UV.x) : (uv2.y - v_UV.y);

        bool isDir1 = (dist1 < dist2);
        float minDist = min(dist1, dist2);
        float edgeLen = (dist1 + dist2);

        float pixelOffset = -minDist / edgeLen + 0.5f;

        bool isLumaCenterSmaller = lumaCenter < lumaLocalAvg;
        bool correctVariation = ((isDir1 ? lumaEnd1 : lumaEnd2) < 0.0f) != isLumaCenterSmaller;
        pixelOffset = correctVariation ? pixelOffset : 0.0f;

        vec2 resultUV = v_UV;
        isHorizontal ? (resultUV.y = resultUV.y + pixelOffset * stepLength) : (resultUV.x = resultUV.x + pixelOffset * stepLength);

        float lumaAvg = (1.0f / 12.0f) * (2.0f * (lumaDownUp + lumaLeftRight) + lumaLeftCorners + lumaRightCorners);
        float subPixelOffset1 = clamp(abs(lumaAvg - lumaCenter) / lumaRange, 0.0f, 1.0f);
        float subPixelOffset2 = (-2.0f * subPixelOffset1 + 3.0f) + subPixelOffset1 * subPixelOffset1;
        float subPixelOffsetResult = subPixelOffset2 * subPixelOffset2 * SUBPIXEL_QUALITY;
        pixelOffset = max(pixelOffset, subPixelOffsetResult);

        fragColorResult = vec4(texture(u_ColorSourcePerceptual, resultUV).xyz, 1.0f);
    }
    else
    {
        fragColorResult = vec4(sampleCenter, 1.0f);
    }
    //fragColorResult = vec4(sampleCenter, 1.0f);
})";

    const char* ShaderInfo::Info_PostFX::VertexSource = R"(#version 330 core
vec2 VERTICES[] = vec2[](vec2(-1.0f, -1.0f),
                         vec2(1.0f, -1.0f),
                         vec2(1.0f, 1.0f),
                         vec2(1.0f, 1.0f),
                         vec2(-1.0f, 1.0f),
                         vec2(-1.0f, -1.0f));
out vec2 v_UV;

void main()
{
    vec4 vertexPos = vec4(VERTICES[min(gl_VertexID, 6)], 0.0f, 1.0f);
    gl_Position = vertexPos;
    v_UV = vertexPos.xy / 2.0f + 0.5f;
})";

    const char* ShaderInfo::Info_PostFX::FragmentSource = R"(#version 330 core
in vec2 v_UV;
out vec4 fragColorResult;

uniform float u_Gamma = 2.4f;
// TODO: Tonemapping
uniform float u_Exposure = 1.0f;

uniform sampler2D u_ColorSourceLinear;

float D3DX_FLOAT_to_SRGB(float val)
{
    if (val < 0.0031308f)
    {
        val *= 12.92f;
    }
    else
    {
        val = 1.055f * pow(val, 1.0f / u_Gamma) - 0.055f;
    }
    return val;
}

vec3 D3DX_RGB_to_SRGB(vec3 rgb)
{
    rgb.r = D3DX_FLOAT_to_SRGB(rgb.r);
    rgb.g = D3DX_FLOAT_to_SRGB(rgb.g);
    rgb.b = D3DX_FLOAT_to_SRGB(rgb.b);
    return rgb;
}

void main()
{
    vec3 hdrSample = texture(u_ColorSourceLinear, v_UV).xyz;
    //vec3 ldrSample = hdrSample / (hdrSample + vec3(1.0f))
    vec3 ldrSample = vec3(1.0f) - exp(-hdrSample * u_Exposure);
    vec3 resultSample = D3DX_RGB_to_SRGB(ldrSample);
    fragColorResult = vec4(resultSample, 1.0f);
})";

    const char* ShaderInfo::Info_Skybox::VertexSource = R"(#version 330 core

uniform mat4 u_ViewMatrix;
uniform mat4 u_ProjMatrix;

out vec3 v_UV;

vec2 VERTICES[] = vec2[](vec2(-1.0f, -1.0f),
                         vec2(1.0f, -1.0f),
                         vec2(1.0f, 1.0f),
                         vec2(1.0f, 1.0f),
                         vec2(-1.0f, 1.0f),
                         vec2(-1.0f, -1.0f));

void main()
{
    vec4 vertexPos = vec4(VERTICES[min(gl_VertexID, 6)], 0.0f, 1.0f);
    gl_Position = vertexPos;
    gl_Position = gl_Position.xyww;
    v_UV = mat3(inverse(u_ViewMatrix)) * (inverse(u_ProjMatrix) * gl_Position).xyz;
    //v_UV = (gl_Position * inverse(u_ViewMatrix) * inverse(u_ProjMatrix)).xyz;
})";

    const char* ShaderInfo::Info_Skybox::FragmentSource = R"(#version 330 core
in vec3 v_UV;

out vec4 f_Color;
uniform float uLod = 1.0f;

uniform samplerCube u_CubeTexture;
void main()
{
    f_Color = textureLod(u_CubeTexture, v_UV, uLod);
})";

    const char* ShaderInfo::Info_Line::VertexSource = R"(#version 330 core
layout (location = 0) in vec3 v_Pos;

out vec3 f_Color;

uniform mat4 u_ViewProjMatrix;
uniform vec3 u_Color;

void main()
{
    gl_Position = u_ViewProjMatrix * vec4(v_Pos, 1.0f);
    f_Color = u_Color;
})";

    const char* ShaderInfo::Info_Line::FragmentSource = R"(#version 330 core
out vec4 fragColor;

in vec3 f_Color;

void main()
{
    fragColor = vec4(f_Color, 1.0f);
})";

    const char* ShaderInfo::Info_Mesh::VertexSource = R"(#version 330 core
layout (location = 0) in vec3 attr_Pos;
layout (location = 1) in vec3 attr_Normal;
layout (location = 2) in vec2 attr_UV;

uniform mat4 u_ViewProjMatrix;
uniform mat4 u_ModelMatrix;
uniform mat3 u_NormalMatrix;

out vec3 vout_FragPos;
out vec3 vout_Normal;
out vec2 vout_UV;

void main()
{
    gl_Position = u_ViewProjMatrix * u_ModelMatrix * vec4(attr_Pos, 1.0f);
    vout_FragPos = (u_ModelMatrix * vec4(attr_Pos, 1.0f)).xyz; //gl_Position.xyz;
    vout_UV = attr_UV;
    vout_Normal = u_NormalMatrix * attr_Normal;
})";

    const char* ShaderInfo::Info_Mesh::FragmentSource = R"(#version 330 core
out vec4 out_Color;

in vec3 vout_FragPos;
in vec3 vout_Normal;
in vec2 vout_UV;

struct DirLight
{
    vec3 dir;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

uniform DirLight u_DirLight;

uniform vec3 u_ViewPos;

uniform sampler2D u_DiffMap;
uniform sampler2D u_SpecMap;

void main()
{
    vec3 normal = normalize(vout_Normal);
    vec4 diffSamle = texture(u_DiffMap, vout_UV);
    vec4 specSample = texture(u_SpecMap, vout_UV);
    specSample.a = 1.0f;
    vec3 lightDir = normalize(-u_DirLight.dir);
    float kDiff = max(dot(normal, lightDir), 0.0f);
    vec3 viewDir = normalize(u_ViewPos - vout_FragPos);
    vec3 rFromLight = reflect(-lightDir, normal);
    float kSpec = pow(max(dot(viewDir, rFromLight), 0.0f), 32.0f);
    vec4 ambient = diffSamle * vec4(u_DirLight.ambient, 1.0f);
    vec4 diffuse = diffSamle * kDiff * vec4(u_DirLight.diffuse, 1.0f);
    vec4 specular = specSample * kSpec * vec4(u_DirLight.specular, 1.0f);
    out_Color = ambient + diffuse + specular;
})";

    const char* ShaderInfo::Info_Chunk::VertexSource = R"(#version 330 core
layout (location = 0) in vec3 a_Position;
layout (location = 1) in vec3 a_Normal;
layout (location = 2) in int a_TileId;

out vec4 v_Position;
out vec3 v_ViewPosition;
out vec3 v_MeshSpacePos;
out vec4 v_LightSpacePos[3];
flat out int v_TileId;
out vec3 v_Normal;
out vec2 v_UV;

#define NUM_SHADOW_CASCADES 3

uniform mat4 u_ModelMatrix;
uniform mat3 u_NormalMatrix;
uniform mat4 u_ViewMatrix;
uniform mat4 u_ProjectionMatrix;
uniform mat4 u_LightSpaceMatrix[3];

#define TERRAIN_TEX_ARRAY_NUM_LAYERS 32
#define INDICES_PER_CHUNK_QUAD 6
#define VERTICES_PER_QUAD 4

vec2 UV[] = vec2[](vec2(0.0f, 0.0f),
                   vec2(1.0f, 0.0f),
                   vec2(1.0f, 1.0f),
                   vec2(0.0f, 1.0f));

void main()
{
    // TODO: Pass ints as vertex attrib
    // This problem will be solved when we switch to using
    // packed vertex attributes

    int vertIndexInQuad = gl_VertexID % 4;

    v_UV = UV[min(vertIndexInQuad, VERTICES_PER_QUAD - 1)];

    v_TileId = a_TileId;
    v_MeshSpacePos = a_Position;
    v_Position = (u_ModelMatrix * vec4(a_Position, 1.0f));
    v_ViewPosition = (u_ViewMatrix * u_ModelMatrix * vec4(a_Position, 1.0f)).xyz;
    v_Normal = u_NormalMatrix * a_Normal;
    v_LightSpacePos[0] = u_LightSpaceMatrix[0] * u_ModelMatrix * vec4(a_Position, 1.0f);
    v_LightSpacePos[1] = u_LightSpaceMatrix[1] * u_ModelMatrix * vec4(a_Position, 1.0f);
    v_LightSpacePos[2] = u_LightSpaceMatrix[2] * u_ModelMatrix * vec4(a_Position, 1.0f);
    gl_Position = u_ProjectionMatrix * u_ViewMatrix * u_ModelMatrix * vec4(a_Position, 1.0f);
})";

    const char* ShaderInfo::Info_Chunk::FragmentSource = R"(#version 330 core

#define NUM_SHADOW_CASCADES 3

// NOTE: Reference: https://github.com/TheRealMJP/Shadows/blob/master/Shadows/PCFKernels.hlsl
const vec2 PoissonSamples[64] = vec2[64]
(
    vec2(-0.5119625f, -0.4827938f),
    vec2(-0.2171264f, -0.4768726f),
    vec2(-0.7552931f, -0.2426507f),
    vec2(-0.7136765f, -0.4496614f),
    vec2(-0.5938849f, -0.6895654f),
    vec2(-0.3148003f, -0.7047654f),
    vec2(-0.42215f, -0.2024607f),
    vec2(-0.9466816f, -0.2014508f),
    vec2(-0.8409063f, -0.03465778f),
    vec2(-0.6517572f, -0.07476326f),
    vec2(-0.1041822f, -0.02521214f),
    vec2(-0.3042712f, -0.02195431f),
    vec2(-0.5082307f, 0.1079806f),
    vec2(-0.08429877f, -0.2316298f),
    vec2(-0.9879128f, 0.1113683f),
    vec2(-0.3859636f, 0.3363545f),
    vec2(-0.1925334f, 0.1787288f),
    vec2(0.003256182f, 0.138135f),
    vec2(-0.8706837f, 0.3010679f),
    vec2(-0.6982038f, 0.1904326f),
    vec2(0.1975043f, 0.2221317f),
    vec2(0.1507788f, 0.4204168f),
    vec2(0.3514056f, 0.09865579f),
    vec2(0.1558783f, -0.08460935f),
    vec2(-0.0684978f, 0.4461993f),
    vec2(0.3780522f, 0.3478679f),
    vec2(0.3956799f, -0.1469177f),
    vec2(0.5838975f, 0.1054943f),
    vec2(0.6155105f, 0.3245716f),
    vec2(0.3928624f, -0.4417621f),
    vec2(0.1749884f, -0.4202175f),
    vec2(0.6813727f, -0.2424808f),
    vec2(-0.6707711f, 0.4912741f),
    vec2(0.0005130528f, -0.8058334f),
    vec2(0.02703013f, -0.6010728f),
    vec2(-0.1658188f, -0.9695674f),
    vec2(0.4060591f, -0.7100726f),
    vec2(0.7713396f, -0.4713659f),
    vec2(0.573212f, -0.51544f),
    vec2(-0.3448896f, -0.9046497f),
    vec2(0.1268544f, -0.9874692f),
    vec2(0.7418533f, -0.6667366f),
    vec2(0.3492522f, 0.5924662f),
    vec2(0.5679897f, 0.5343465f),
    vec2(0.5663417f, 0.7708698f),
    vec2(0.7375497f, 0.6691415f),
    vec2(0.2271994f, -0.6163502f),
    vec2(0.2312844f, 0.8725659f),
    vec2(0.4216993f, 0.9002838f),
    vec2(0.4262091f, -0.9013284f),
    vec2(0.2001408f, -0.808381f),
    vec2(0.149394f, 0.6650763f),
    vec2(-0.09640376f, 0.9843736f),
    vec2(0.7682328f, -0.07273844f),
    vec2(0.04146584f, 0.8313184f),
    vec2(0.9705266f, -0.1143304f),
    vec2(0.9670017f, 0.1293385f),
    vec2(0.9015037f, -0.3306949f),
    vec2(-0.5085648f, 0.7534177f),
    vec2(0.9055501f, 0.3758393f),
    vec2(0.7599946f, 0.1809109f),
    vec2(-0.2483695f, 0.7942952f),
    vec2(-0.4241052f, 0.5581087f),
    vec2(-0.1020106f, 0.6724468f)
);

vec3 CascadeColors[NUM_SHADOW_CASCADES] = vec3[NUM_SHADOW_CASCADES]
(
    vec3(1.0f, 0.0f, 0.0f),
    vec3(0.0f, 1.0f, 0.0f),
    vec3(0.0f, 0.0f, 1.0f)
);

int GetShadowCascadeIndex(float viewSpaceDepth, vec3 bounds)
{
    int cascadeNum = 0;

    for (int i = 0; i < NUM_SHADOW_CASCADES; i++)
    {
        if (viewSpaceDepth < bounds[i])
        {
            cascadeNum = i;
            break;
        }
    }
    return cascadeNum;
}

vec3 ShadowPCF(in sampler2DArrayShadow shadowMap, int cascadeIndex,
               vec3 lightSpaceP, float viewSpaceDepth,
               float filterSampleScale, int showCascadeBounds)
{
    float kShadow = 0.0f;
    vec2 sampleScale = (1.0f / textureSize(shadowMap, 0).xy) * filterSampleScale;
    int sampleCount = 0;
    for (int y = -2; y <= 1; y++)
    {
        for (int x = -2; x <= 1; x++)
        {
            vec4 uv = vec4(lightSpaceP.xy + vec2(x, y) * sampleScale, float(cascadeIndex), lightSpaceP.z);
            kShadow += texture(shadowMap, uv);
            sampleCount++;
        }
    }
    kShadow /= sampleCount;

    vec3 result;
    if (showCascadeBounds == 1)
    {
        vec3 cascadeColor = CascadeColors[cascadeIndex];
        result = vec3(kShadow) * cascadeColor;
    }
    else
    {
        result = vec3(kShadow);
    }
    return result;
}

vec3 ShadowRandomDisc(in sampler2DArrayShadow shadowMap, in sampler1D randomTexture,
                      int cascadeIndex, vec3 lightSpaceP, float viewSpaceDepth,
                      float filterSampleScale, int showCascadeBounds)
{
    float kShadow = 0.0f;
    vec2 sampleScale = (1.0f / textureSize(shadowMap, 0).xy) * filterSampleScale;

#if RANDOMIZE_OFFSETS
    int randomTextureSize = textureSize(randomTexture, 0);
    // TODO: Better random here
    int randomSamplePos = int(gl_FragCoord.x + 845.0f * gl_FragCoord.y) % randomTextureSize;
    float theta = texelFetch(randomTexture, randomSamplePos, 0).r * 2.0f * PI;
    mat2 randomRotationMtx;
    randomRotationMtx[0] = vec2(cos(theta), sin(theta));
    randomRotationMtx[1] = vec2(-sin(theta), cos(theta));
    //randomRotationMtx[0] = vec2(cos(theta), -sin(theta));
    //randomRotationMtx[1] = vec2(sin(theta), cos(theta));
#endif

    const int sampleCount = 16;

    for (int i = 0; i < sampleCount; i++)
    {
#if RANDOMIZE_OFFSETS
        vec2 sampleOffset = (randomRotationMtx * PoissonSamples[i]) * sampleScale;
#else
        vec2 sampleOffset = PoissonSamples[i] *  sampleScale;
#endif
        vec4 uv = vec4(lightSpaceP.xy + sampleOffset, cascadeIndex, lightSpaceP.z);
        kShadow += texture(shadowMap, uv);
    }
    kShadow /= sampleCount;

    vec3 result;
    if (showCascadeBounds == 1)
    {
        vec3 cascadeColor = CascadeColors[cascadeIndex];
        result = vec3(kShadow) * cascadeColor;
    }
    else
    {
        result = vec3(kShadow);
    }
    return result;
}



in vec4 v_Position;
in vec3 v_ViewPosition;
in vec4 v_LightSpacePos[3];
flat in int v_TileId;
in vec3 v_Normal;
in vec2 v_UV;

out vec4 color;

struct DirLight
{
    vec3 dir;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

uniform DirLight u_DirLight;
uniform vec3 u_ViewPos;
uniform sampler2DArray u_TerrainAtlas;
uniform sampler2DArrayShadow u_ShadowMap;
uniform vec3 u_ShadowCascadeSplits;
uniform int u_ShowShadowCascadesBoundaries = 0;

uniform float shadowFilterSampleScale = 1.0f;
uniform sampler1D randomTexture;

#define PI (3.14159265359)

//#define RANDOM_DISC_PCF 1
#define RANDOMIZE_OFFSETS 1
#define DUMMY_PCF 1


vec3 CalcDirectionalLight(DirLight light, vec3 normal,
                          vec3 viewDir,
                          vec3 diffSample)
{
    vec3 lightDir = normalize(-light.dir);
    vec3 lightDirReflected = reflect(-lightDir, normal);

    float Kd = max(dot(normal, lightDir), 0.0);

    float viewSpaceDepth = -v_ViewPosition.z;
    int cascadeIndex = GetShadowCascadeIndex(-v_ViewPosition.z, u_ShadowCascadeSplits);
    vec3 lightSpaceP = v_LightSpacePos[cascadeIndex].xyz / v_LightSpacePos[cascadeIndex].w;
   lightSpaceP = lightSpaceP * 0.5f + 0.5f;
#if DUMMY_PCF
   vec3 Kshadow = ShadowPCF(u_ShadowMap, cascadeIndex, lightSpaceP, viewSpaceDepth, shadowFilterSampleScale, u_ShowShadowCascadesBoundaries);
#endif
#if RANDOM_DISC_PCF
   vec3 Kshadow = ShadowRandomDisc(u_ShadowMap, randomTexture, cascadeIndex, lightSpaceP, viewSpaceDepth, shadowFilterSampleScale, u_ShowShadowCascadesBoundaries);
#endif

    vec3 ambient = light.ambient * diffSample;
    vec3 diffuse = Kd * light.diffuse * diffSample * Kshadow;
    return ambient + diffuse;
}

#define TERRAIN_TEX_ARRAY_NUM_LAYERS 32

void main()
{
    vec3 normal = normalize(v_Normal);
    vec3 viewDir = normalize(u_ViewPos - v_Position.xyz);

    int tileID = clamp(v_TileId, 0, TERRAIN_TEX_ARRAY_NUM_LAYERS);

    vec3 diffSample;
    float alpha;
    diffSample = texture(u_TerrainAtlas, vec3(v_UV.x, v_UV.y, tileID)).rgb;
    alpha = 1.0f;

    vec3 directional = CalcDirectionalLight(u_DirLight, normal, viewDir, diffSample);
    //directional = diffSample;

    color = vec4(directional, alpha);
}
)";

    const char* ShaderInfo::Info_Shadow::VertexSource = R"(#version 330 core
layout (location = 0) in vec3 Position;
layout (location = 1) in vec3 Normal;

uniform mat4 ModelMatrix;
uniform mat4 ViewProjMatrix;
uniform mat3 NormalMatrix;
uniform vec3 LightPos;

uniform float ShadowNormalBiasScale = 0.0f;

void main()
{
    vec3 normal = normalize(NormalMatrix * normalize(Normal));
    float NdotL = dot(normal, LightPos);
    vec3 p = (ModelMatrix * vec4(Position, 1.0f)).xyz;
    //p += normal * ShadowNormalBiasScale;
    gl_Position = ViewProjMatrix * vec4(p, 1.0f);
})";

    const char* ShaderInfo::Info_Shadow::FragmentSource = R"(#version 330 core
out vec4 color;

uniform float ConstantShadowBias = 0.0f;

void main()
{
    gl_FragDepth = gl_FragCoord.z + ConstantShadowBias;
    color = vec4(gl_FragCoord.z, gl_FragCoord.z, gl_FragCoord.z, 1.0f);
}
)";

}
