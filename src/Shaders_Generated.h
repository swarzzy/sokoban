// This file was generated by a glsl preprocessor

#pragma once
namespace soko
{
    struct Shaders
    {
        GLuint Chunk;
        GLuint Mesh;
        GLuint Line;
        GLuint PbrMesh;
    };

    const char* ShaderNames[] =
    {
        "Chunk",
        "Mesh",
        "Line",
        "PbrMesh",
    };

    const ShaderProgramSource ShaderSources[] =
    {
        {
            R"(#version 450
#line 100000
struct DirLight
{
    vec3 dir;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

layout (std140, binding = 0) uniform ShaderFrameData
{
    mat4 viewProjMatrix;
    mat4 viewMatrix;
    mat4 projectionMatrix;
    mat4 lightSpaceMatrices[3];
    DirLight dirLight;
    vec3 viewPos;
    vec3 shadowCascadeSplits;
    int showShadowCascadeBoundaries;
    float shadowFilterSampleScale;
    int debugF;
    int debugG;
    int debugD;
    int debugNormals;
} FrameData;

layout (std140, binding = 1) uniform ShaderMeshData
{
    mat4 modelMatrix;
    mat3 normalMatrix;
    vec3 lineColor;
    int customMaterial;
    vec3 customAlbedo;
    float customRoughness;
    float customMetalness;
} MeshData;

#line 2

layout (location = 0) in vec3 a_Position;
layout (location = 1) in vec3 a_Normal;
layout (location = 2) in int a_TileId;

layout (location = 3) out vec3 v_ViewPosition;
layout (location = 4) out vec4 v_LightSpacePos[3];
layout (location = 7) flat out int v_TileId;
layout (location = 8) out vec3 v_Normal;
layout (location = 9) out vec2 v_UV;
layout (location = 10) out vec4 v_Position;


#define NUM_SHADOW_CASCADES 3
#define TERRAIN_TEX_ARRAY_NUM_LAYERS 32
#define INDICES_PER_CHUNK_QUAD 6
#define VERTICES_PER_QUAD 4

vec2 UV[] = vec2[](vec2(0.0f, 0.0f),
                   vec2(1.0f, 0.0f),
                   vec2(1.0f, 1.0f),
                   vec2(0.0f, 1.0f));


void main()
{
    // TODO: Pass ints as vertex attrib
    // This problem will be solved when we switch to using
    // packed vertex attributes

    int vertIndexInQuad = gl_VertexID % 4;

    v_UV = UV[min(vertIndexInQuad, VERTICES_PER_QUAD - 1)];

    v_TileId = a_TileId;
    v_Position = (MeshData.modelMatrix * vec4(a_Position, 1.0f));
    v_ViewPosition = (FrameData.viewMatrix * MeshData.modelMatrix * vec4(a_Position, 1.0f)).xyz;
    v_Normal = MeshData.normalMatrix * a_Normal;
    v_LightSpacePos[0] = FrameData.lightSpaceMatrices[0] * MeshData.modelMatrix * vec4(a_Position, 1.0f);
    v_LightSpacePos[1] = FrameData.lightSpaceMatrices[1] * MeshData.modelMatrix * vec4(a_Position, 1.0f);
    v_LightSpacePos[2] = FrameData.lightSpaceMatrices[2] * MeshData.modelMatrix * vec4(a_Position, 1.0f);
    gl_Position = FrameData.projectionMatrix * FrameData.viewMatrix * MeshData.modelMatrix * vec4(a_Position, 1.0f);
}
)", 
R"(#version 450

#line 100000
struct DirLight
{
    vec3 dir;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

layout (std140, binding = 0) uniform ShaderFrameData
{
    mat4 viewProjMatrix;
    mat4 viewMatrix;
    mat4 projectionMatrix;
    mat4 lightSpaceMatrices[3];
    DirLight dirLight;
    vec3 viewPos;
    vec3 shadowCascadeSplits;
    int showShadowCascadeBoundaries;
    float shadowFilterSampleScale;
    int debugF;
    int debugG;
    int debugD;
    int debugNormals;
} FrameData;

layout (std140, binding = 1) uniform ShaderMeshData
{
    mat4 modelMatrix;
    mat3 normalMatrix;
    vec3 lineColor;
    int customMaterial;
    vec3 customAlbedo;
    float customRoughness;
    float customMetalness;
} MeshData;

#line 3
#line 100000

#define NUM_SHADOW_CASCADES 3

// NOTE: Reference: https://github.com/TheRealMJP/Shadows/blob/master/Shadows/PCFKernels.hlsl
const vec2 PoissonSamples[64] = vec2[64]
(
    vec2(-0.5119625f, -0.4827938f),
    vec2(-0.2171264f, -0.4768726f),
    vec2(-0.7552931f, -0.2426507f),
    vec2(-0.7136765f, -0.4496614f),
    vec2(-0.5938849f, -0.6895654f),
    vec2(-0.3148003f, -0.7047654f),
    vec2(-0.42215f, -0.2024607f),
    vec2(-0.9466816f, -0.2014508f),
    vec2(-0.8409063f, -0.03465778f),
    vec2(-0.6517572f, -0.07476326f),
    vec2(-0.1041822f, -0.02521214f),
    vec2(-0.3042712f, -0.02195431f),
    vec2(-0.5082307f, 0.1079806f),
    vec2(-0.08429877f, -0.2316298f),
    vec2(-0.9879128f, 0.1113683f),
    vec2(-0.3859636f, 0.3363545f),
    vec2(-0.1925334f, 0.1787288f),
    vec2(0.003256182f, 0.138135f),
    vec2(-0.8706837f, 0.3010679f),
    vec2(-0.6982038f, 0.1904326f),
    vec2(0.1975043f, 0.2221317f),
    vec2(0.1507788f, 0.4204168f),
    vec2(0.3514056f, 0.09865579f),
    vec2(0.1558783f, -0.08460935f),
    vec2(-0.0684978f, 0.4461993f),
    vec2(0.3780522f, 0.3478679f),
    vec2(0.3956799f, -0.1469177f),
    vec2(0.5838975f, 0.1054943f),
    vec2(0.6155105f, 0.3245716f),
    vec2(0.3928624f, -0.4417621f),
    vec2(0.1749884f, -0.4202175f),
    vec2(0.6813727f, -0.2424808f),
    vec2(-0.6707711f, 0.4912741f),
    vec2(0.0005130528f, -0.8058334f),
    vec2(0.02703013f, -0.6010728f),
    vec2(-0.1658188f, -0.9695674f),
    vec2(0.4060591f, -0.7100726f),
    vec2(0.7713396f, -0.4713659f),
    vec2(0.573212f, -0.51544f),
    vec2(-0.3448896f, -0.9046497f),
    vec2(0.1268544f, -0.9874692f),
    vec2(0.7418533f, -0.6667366f),
    vec2(0.3492522f, 0.5924662f),
    vec2(0.5679897f, 0.5343465f),
    vec2(0.5663417f, 0.7708698f),
    vec2(0.7375497f, 0.6691415f),
    vec2(0.2271994f, -0.6163502f),
    vec2(0.2312844f, 0.8725659f),
    vec2(0.4216993f, 0.9002838f),
    vec2(0.4262091f, -0.9013284f),
    vec2(0.2001408f, -0.808381f),
    vec2(0.149394f, 0.6650763f),
    vec2(-0.09640376f, 0.9843736f),
    vec2(0.7682328f, -0.07273844f),
    vec2(0.04146584f, 0.8313184f),
    vec2(0.9705266f, -0.1143304f),
    vec2(0.9670017f, 0.1293385f),
    vec2(0.9015037f, -0.3306949f),
    vec2(-0.5085648f, 0.7534177f),
    vec2(0.9055501f, 0.3758393f),
    vec2(0.7599946f, 0.1809109f),
    vec2(-0.2483695f, 0.7942952f),
    vec2(-0.4241052f, 0.5581087f),
    vec2(-0.1020106f, 0.6724468f)
);

vec3 CascadeColors[NUM_SHADOW_CASCADES] = vec3[NUM_SHADOW_CASCADES]
(
    vec3(1.0f, 0.0f, 0.0f),
    vec3(0.0f, 1.0f, 0.0f),
    vec3(0.0f, 0.0f, 1.0f)
);

int GetShadowCascadeIndex(float viewSpaceDepth, vec3 bounds)
{
    int cascadeNum = 0;

    for (int i = 0; i < NUM_SHADOW_CASCADES; i++)
    {
        if (viewSpaceDepth < bounds[i])
        {
            cascadeNum = i;
            break;
        }
    }
    return cascadeNum;
}

vec3 ShadowPCF(in sampler2DArrayShadow shadowMap, int cascadeIndex,
               vec3 lightSpaceP, float viewSpaceDepth,
               float filterSampleScale, int showCascadeBounds)
{
    float kShadow = 0.0f;
    vec2 sampleScale = (1.0f / textureSize(shadowMap, 0).xy) * filterSampleScale;
    int sampleCount = 0;
    for (int y = -2; y <= 1; y++)
    {
        for (int x = -2; x <= 1; x++)
        {
            vec4 uv = vec4(lightSpaceP.xy + vec2(x, y) * sampleScale, float(cascadeIndex), lightSpaceP.z);
            kShadow += texture(shadowMap, uv);
            sampleCount++;
        }
    }
    kShadow /= sampleCount;

    vec3 result;
    if (showCascadeBounds == 1)
    {
        vec3 cascadeColor = CascadeColors[cascadeIndex];
        result = vec3(kShadow) * cascadeColor;
    }
    else
    {
        result = vec3(kShadow);
    }
    return result;
}

vec3 ShadowRandomDisc(in sampler2DArrayShadow shadowMap, in sampler1D randomTexture,
                      int cascadeIndex, vec3 lightSpaceP, float viewSpaceDepth,
                      float filterSampleScale, int showCascadeBounds)
{
    float kShadow = 0.0f;
    vec2 sampleScale = (1.0f / textureSize(shadowMap, 0).xy) * filterSampleScale;

#if RANDOMIZE_OFFSETS
    int randomTextureSize = textureSize(randomTexture, 0);
    // TODO: Better random here
    int randomSamplePos = int(gl_FragCoord.x + 845.0f * gl_FragCoord.y) % randomTextureSize;
    float theta = texelFetch(randomTexture, randomSamplePos, 0).r * 2.0f * PI;
    mat2 randomRotationMtx;
    randomRotationMtx[0] = vec2(cos(theta), sin(theta));
    randomRotationMtx[1] = vec2(-sin(theta), cos(theta));
    //randomRotationMtx[0] = vec2(cos(theta), -sin(theta));
    //randomRotationMtx[1] = vec2(sin(theta), cos(theta));
#endif

    const int sampleCount = 16;

    for (int i = 0; i < sampleCount; i++)
    {
#if RANDOMIZE_OFFSETS
        vec2 sampleOffset = (randomRotationMtx * PoissonSamples[i]) * sampleScale;
#else
        vec2 sampleOffset = PoissonSamples[i] *  sampleScale;
#endif
        vec4 uv = vec4(lightSpaceP.xy + sampleOffset, cascadeIndex, lightSpaceP.z);
        kShadow += texture(shadowMap, uv);
    }
    kShadow /= sampleCount;

    vec3 result;
    if (showCascadeBounds == 1)
    {
        vec3 cascadeColor = CascadeColors[cascadeIndex];
        result = vec3(kShadow) * cascadeColor;
    }
    else
    {
        result = vec3(kShadow);
    }
    return result;
}

#line 4

layout (location = 3) in vec3 v_ViewPosition;
layout (location = 4) in vec4 v_LightSpacePos[3];
layout (location = 7) flat in int v_TileId;
layout (location = 8) in vec3 v_Normal;
layout (location = 9) in vec2 v_UV;
layout (location = 10) in vec4 v_Position;

out vec4 color;

layout (binding = 0) uniform sampler2DArray u_TerrainAtlas;
layout (binding = 1) uniform sampler2DArrayShadow u_ShadowMap;
layout (binding = 2) uniform sampler1D randomTexture;

#define PI (3.14159265359)

//#define RANDOM_DISC_PCF 1
#define RANDOMIZE_OFFSETS 1
#define DUMMY_PCF 1


vec3 CalcDirectionalLight(DirLight light, vec3 normal, vec3 viewDir, vec3 diffSample)
{
    vec3 lightDir = normalize(-light.dir);
    vec3 lightDirReflected = reflect(-lightDir, normal);

    float Kd = max(dot(normal, lightDir), 0.0);

    float viewSpaceDepth = -v_ViewPosition.z;
    int cascadeIndex = GetShadowCascadeIndex(-v_ViewPosition.z, FrameData.shadowCascadeSplits);
    vec3 lightSpaceP = v_LightSpacePos[cascadeIndex].xyz / v_LightSpacePos[cascadeIndex].w;
    lightSpaceP = lightSpaceP * 0.5f + 0.5f;
#if DUMMY_PCF
   vec3 Kshadow = ShadowPCF(u_ShadowMap, cascadeIndex, lightSpaceP, viewSpaceDepth, FrameData.shadowFilterSampleScale, FrameData.showShadowCascadeBoundaries);
#endif
#if RANDOM_DISC_PCF
   vec3 Kshadow = ShadowRandomDisc(u_ShadowMap, randomTexture, cascadeIndex, lightSpaceP, viewSpaceDepth, FrameData.shadowFilterSampleScale, FrameData.showShadowCascadeBoundaries);
#endif

    vec3 ambient = light.ambient * diffSample;
    vec3 diffuse = Kd * light.diffuse * diffSample * Kshadow;
    return ambient + diffuse;
}

#define TERRAIN_TEX_ARRAY_NUM_LAYERS 32

void main()
{
    vec3 normal = normalize(v_Normal);
    vec3 viewDir = normalize(FrameData.viewPos - v_Position.xyz);

    int tileID = clamp(v_TileId, 0, TERRAIN_TEX_ARRAY_NUM_LAYERS);

    vec3 diffSample;
    float alpha;
    diffSample = texture(u_TerrainAtlas, vec3(v_UV.x, v_UV.y, tileID)).rgb;
    alpha = 1.0f;

    vec3 directional = CalcDirectionalLight(FrameData.dirLight, normal, viewDir, diffSample);
    //directional = diffSample;

    color = vec4(directional, alpha);
}
)"
        },
        {
            R"(#version 450
#line 100000
struct DirLight
{
    vec3 dir;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

layout (std140, binding = 0) uniform ShaderFrameData
{
    mat4 viewProjMatrix;
    mat4 viewMatrix;
    mat4 projectionMatrix;
    mat4 lightSpaceMatrices[3];
    DirLight dirLight;
    vec3 viewPos;
    vec3 shadowCascadeSplits;
    int showShadowCascadeBoundaries;
    float shadowFilterSampleScale;
    int debugF;
    int debugG;
    int debugD;
    int debugNormals;
} FrameData;

layout (std140, binding = 1) uniform ShaderMeshData
{
    mat4 modelMatrix;
    mat3 normalMatrix;
    vec3 lineColor;
    int customMaterial;
    vec3 customAlbedo;
    float customRoughness;
    float customMetalness;
} MeshData;

#line 2
layout (location = 0) in vec3 attr_Pos;
layout (location = 1) in vec3 attr_Normal;
layout (location = 2) in vec2 attr_UV;

layout (location = 3) out vec3 vout_FragPos;
layout (location = 4) out vec3 vout_Normal;
layout (location = 5) out vec2 vout_UV;

void main()
{
    gl_Position = FrameData.projectionMatrix * FrameData.viewMatrix * MeshData.modelMatrix * vec4(attr_Pos, 1.0f);
    vout_FragPos = (MeshData.modelMatrix * vec4(attr_Pos, 1.0f)).xyz;
    vout_UV = attr_UV;
    vout_Normal = MeshData.normalMatrix * attr_Normal;
}
)", 
R"(#version 450
#line 100000
struct DirLight
{
    vec3 dir;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

layout (std140, binding = 0) uniform ShaderFrameData
{
    mat4 viewProjMatrix;
    mat4 viewMatrix;
    mat4 projectionMatrix;
    mat4 lightSpaceMatrices[3];
    DirLight dirLight;
    vec3 viewPos;
    vec3 shadowCascadeSplits;
    int showShadowCascadeBoundaries;
    float shadowFilterSampleScale;
    int debugF;
    int debugG;
    int debugD;
    int debugNormals;
} FrameData;

layout (std140, binding = 1) uniform ShaderMeshData
{
    mat4 modelMatrix;
    mat3 normalMatrix;
    vec3 lineColor;
    int customMaterial;
    vec3 customAlbedo;
    float customRoughness;
    float customMetalness;
} MeshData;

#line 2

out vec4 out_Color;

layout (location = 3) in vec3 vout_FragPos;
layout (location = 4) in vec3 vout_Normal;
layout (location = 5) in vec2 vout_UV;

layout (binding = 0) uniform sampler2D u_DiffMap;
layout (binding = 1) uniform sampler2D u_SpecMap;

void main()
{
    vec3 normal = normalize(vout_Normal);
    vec4 diffSamle = texture(u_DiffMap, vout_UV);
    vec4 specSample = texture(u_SpecMap, vout_UV);
    specSample.a = 1.0f;
    vec3 lightDir = normalize(-FrameData.dirLight.dir);
    float kDiff = max(dot(normal, lightDir), 0.0f);
    vec3 viewDir = normalize(FrameData.viewPos - vout_FragPos);
    vec3 rFromLight = reflect(-lightDir, normal);
    float kSpec = pow(max(dot(viewDir, rFromLight), 0.0f), 32.0f);
    vec4 ambient = diffSamle * vec4(FrameData.dirLight.ambient, 1.0f);
    vec4 diffuse = diffSamle * kDiff * vec4(FrameData.dirLight.diffuse, 1.0f);
    vec4 specular = specSample * kSpec * vec4(FrameData.dirLight.specular, 1.0f);
    out_Color = ambient + diffuse + specular;
}
)"
        },
        {
            R"(#version 450
#line 100000
struct DirLight
{
    vec3 dir;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

layout (std140, binding = 0) uniform ShaderFrameData
{
    mat4 viewProjMatrix;
    mat4 viewMatrix;
    mat4 projectionMatrix;
    mat4 lightSpaceMatrices[3];
    DirLight dirLight;
    vec3 viewPos;
    vec3 shadowCascadeSplits;
    int showShadowCascadeBoundaries;
    float shadowFilterSampleScale;
    int debugF;
    int debugG;
    int debugD;
    int debugNormals;
} FrameData;

layout (std140, binding = 1) uniform ShaderMeshData
{
    mat4 modelMatrix;
    mat3 normalMatrix;
    vec3 lineColor;
    int customMaterial;
    vec3 customAlbedo;
    float customRoughness;
    float customMetalness;
} MeshData;

#line 2
layout (location = 0) in vec3 Pos;

layout (location = 1) out vec3 Color;

void main()
{
    gl_Position = FrameData.viewProjMatrix * vec4(Pos, 1.0f);
    Color = MeshData.lineColor;
}
)", 
R"(#version 450
out vec4 fragColor;

layout(location = 1) in vec3 Color;

void main()
{
    fragColor = vec4(Color, 1.0f);
}
)"
        },
        {
            R"(#version 450
#line 100000
struct DirLight
{
    vec3 dir;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

layout (std140, binding = 0) uniform ShaderFrameData
{
    mat4 viewProjMatrix;
    mat4 viewMatrix;
    mat4 projectionMatrix;
    mat4 lightSpaceMatrices[3];
    DirLight dirLight;
    vec3 viewPos;
    vec3 shadowCascadeSplits;
    int showShadowCascadeBoundaries;
    float shadowFilterSampleScale;
    int debugF;
    int debugG;
    int debugD;
    int debugNormals;
} FrameData;

layout (std140, binding = 1) uniform ShaderMeshData
{
    mat4 modelMatrix;
    mat3 normalMatrix;
    vec3 lineColor;
    int customMaterial;
    vec3 customAlbedo;
    float customRoughness;
    float customMetalness;
} MeshData;

#line 2
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aUV;
layout (location = 3) in vec3 aTangent;

layout (location = 4) out vec3 vFragPos;
layout (location = 5) out vec3 vNormal;
layout (location = 6) out vec2 vUV;
layout (location = 7) out mat3 vTBN;

void main()
{
    vec3 n = normalize(MeshData.normalMatrix * aNormal);
    vec3 t = normalize(MeshData.normalMatrix * aTangent);
    t = normalize(t - dot(t, n) * n);
    vec3 b = normalize(cross(n, t));
    mat3 tbn = mat3(t, b, n);

    gl_Position = FrameData.viewProjMatrix * MeshData.modelMatrix * vec4(aPos, 1.0f);
    vFragPos = (MeshData.modelMatrix * vec4(aPos, 1.0f)).xyz;
    vUV = aUV;
    vNormal = n;
    vTBN = tbn;
}
)", 
R"(#version 450
#line 100000
struct DirLight
{
    vec3 dir;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

layout (std140, binding = 0) uniform ShaderFrameData
{
    mat4 viewProjMatrix;
    mat4 viewMatrix;
    mat4 projectionMatrix;
    mat4 lightSpaceMatrices[3];
    DirLight dirLight;
    vec3 viewPos;
    vec3 shadowCascadeSplits;
    int showShadowCascadeBoundaries;
    float shadowFilterSampleScale;
    int debugF;
    int debugG;
    int debugD;
    int debugNormals;
} FrameData;

layout (std140, binding = 1) uniform ShaderMeshData
{
    mat4 modelMatrix;
    mat3 normalMatrix;
    vec3 lineColor;
    int customMaterial;
    vec3 customAlbedo;
    float customRoughness;
    float customMetalness;
} MeshData;

#line 2

out vec4 resultColor;

layout (location = 4) in vec3 vFragPos;
layout (location = 5) in vec3 vNormal;
layout (location = 6) in vec2 vUV;
layout (location = 7) in mat3 vTBN;

layout (binding = 0) uniform samplerCube uIrradanceMap;
layout (binding = 1) uniform samplerCube uEnviromentMap;
layout (binding = 2) uniform sampler2D uBRDFLut;

layout (binding = 3) uniform sampler2D uAlbedoMap;
layout (binding = 4) uniform sampler2D uRoughnessMap;
layout (binding = 5) uniform sampler2D uMetalnessMap;
layout (binding = 6) uniform sampler2D uNormalMap;
//uniform sampler2D uAOMap;

const float MAX_REFLECTION_LOD = 5.0f;

#define PI (3.14159265359)

vec3 FresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (vec3(1.0f) - F0) * pow(1.0f - cosTheta, 5.0f);
}

vec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0f - roughness), F0) - F0) * pow(1.0f - cosTheta, 5.0f);
}

float DistributionGGX(vec3 N, vec3 H, float a)
{
    float a4 = a * a * a * a;
    float NdotH = max(dot(N, H), 0.0f);
    float NdotHSq = NdotH * NdotH;

    float num = a4;
    float denom = (NdotHSq * (a4 - 1.0f) + 1.0f);
    denom = PI * denom * denom;

    return num / max(denom, 0.001f);
}

float GeometrySchlickGGX(float NdotV, float a)
{
    float k = ((a + 1.0f) * (a + 1.0f)) / 8.0f;

    float num = NdotV;
    float denom = NdotV * (1.0f - k) + k;

    return num / denom;
}

float GeometrySmith(float NdotV, float NdotL, float a)
{
    float ggx1 = GeometrySchlickGGX(NdotV, a);
    float ggx2 = GeometrySchlickGGX(NdotL, a);

    return ggx1 * ggx2;
}

vec3 IBLIrradance(vec3 Vo, vec3 N, float NdotV, float a, vec3 F0, float metallic, vec3 albedo)
{
    // NOTE: Specular irradance
    vec3 R = reflect(-Vo, N);
    vec3 envIrradance = textureLod(uEnviromentMap, R, a * MAX_REFLECTION_LOD).rgb;
    vec3 Fenv = FresnelSchlickRoughness(NdotV, F0, a);
    vec2 envBRDF = texture(uBRDFLut, vec2(NdotV, a)).rg;
    vec3 envSpecular = envIrradance * (Fenv * envBRDF.r + envBRDF.g);

    // NOTE: Diffuse irradance
    vec3 kS = FresnelSchlick(NdotV, F0);
    vec3 kD = vec3(1.0f) - kS;
    kD *= 1.0f - metallic;
    vec3 diffIrradance = texture(uIrradanceMap, N).rgb;
    vec3 diffuse = diffIrradance * albedo;

    vec3 irradance = (kD * diffuse + envSpecular);// * uAO;
    return irradance;
}

void main()
{
    vec3 N;
    vec3 albedo;
    float roughness;
    float metalness;

    if (MeshData.customMaterial == 1)
    {
        N = normalize(vNormal);
        albedo = MeshData.customAlbedo;
        roughness = MeshData.customRoughness;
        metalness = MeshData.customMetalness;
    }
    else
    {
         N = normalize(texture(uNormalMap, vUV).xyz * 2.0f - 1.0f);
         // NOTE: Flipping y because engine uses LH normal maps (UE4) but OpenGL does it's job in RH space
         N.y = -N.y;
         N = normalize(vTBN * N);
         albedo = texture(uAlbedoMap, vUV).xyz;
         roughness = texture(uRoughnessMap, vUV).r;
         metalness = texture(uMetalnessMap, vUV).r;
    }

    vec3 V = normalize(FrameData.viewPos - vFragPos);
    vec3 L0 = vec3(0.0f);

    vec3 L = normalize(-FrameData.dirLight.dir);
    vec3 H = normalize(V + L);

    // TODO: Adding this to avoid artifacts on edges
    // Why this value so big?
    float NdotV = max(dot(N, V), 0.0f);// + 0.000001f; // NOTE: Adding this value (trick from epic games shaders) reduces artifacts on the edges in Intel gpu's but completely brokes everything on nvidia
    float NdotL = max(dot(N, L), 0.0f);

    // NOTE: Attenuation should be here
    vec3 radiance = FrameData.dirLight.diffuse;

    vec3 F0 = vec3(0.04f);
    F0 = mix(F0, albedo, metalness);

    // NOTE: Seems like it prodices visually incorrect result with H vector
    // and N gives more Fresnel-look-like result
    // but in papers people usually use H
    vec3 F = FresnelSchlick(max(dot(H, V), 0.0f), F0);
    float D = DistributionGGX(N, H, roughness);
    float G = GeometrySmith(NdotV, NdotL, roughness);

    vec3 num = D * G * F;
    float denom = 4.0f * NdotV * NdotL;;
    vec3 specular = num / max(denom, 0.001f);

    {
        vec3 kS = F;
        vec3 kD = vec3(1.0f) - kS;
        kD *= 1.0f - metalness;
        L0 += (kD * albedo / PI + specular) * radiance * NdotL;
    }

    vec3 envIrradance = IBLIrradance(V, N, NdotV, roughness, F0, metalness, albedo);

    resultColor = vec4((envIrradance + L0), 1.0f);

    if (FrameData.debugF == 1) resultColor = vec4(F,  1.0f);
    else if (FrameData.debugG == 1) resultColor = vec4(G, G, G, 1.0f);
    else if (FrameData.debugD == 1) resultColor = vec4(D, D, D, 1.0f);
    else if (FrameData.debugNormals == 1) resultColor = vec4(N, 1.0f);
}
)"
        },
    };
}
